<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML+RDFa 1.0//EN" "http://www.w3.org/MarkUp/DTD/xhtml-rdfa-1.dtd">
<html dir="ltr" xmlns:og="http://ogp.me/ns#" xmlns:article="http://ogp.me/ns/article#" xmlns:book="http://ogp.me/ns/book#" xmlns:profile="http://ogp.me/ns/profile#" xmlns:video="http://ogp.me/ns/video#" xmlns:product="http://ogp.me/ns/product#" class="js csstransforms csstransforms3d csstransitions" lang="en"><head profile="http://www.w3.org/1999/xhtml/vocab"><style>body{counter-reset: h1 h2 h3 h4 h5 h6 paragraph}.md code,pre{font-family:Menlo,Consolas,monospace;font-size:13.141452225px;line-height:140%}.md div.title{font-size:26px;font-weight:800;line-height:120%;text-align:center}.md div.afterTitles{height:10px}.md div.subtitle{text-align:center}.md .image{display:inline-block}.md div.imagecaption,.md div.tablecaption,.md div.listingcaption{margin:5px 5px 5px 5px;text-align: justify;font-style:italic}.md div.imagecaption{margin-bottom:0}.md img{max-width:100%;page-break-inside:avoid}.md li{text-align:left}.md pre.listing {tab-size:4;-moz-tab-size:4;-o-tab-size:4}.md div.tilde{margin:20px 0 -10px;text-align:center}.md blockquote.fancyquote{margin:25px 0 25px;text-align:left;line-height:160%}.md blockquote.fancyquote::before{content:"“";color:#DDD;font-family:Times New Roman;font-size:45px;line-height:0;margin-right:6px;vertical-align:-0.3em}.md span.fancyquote{font-size:118%;color:#777;font-style:italic}.md span.fancyquote::after{content:"”";font-style:normal;color:#DDD;font-family:Times New Roman;font-size:45px;line-height:0;margin-left:6px;vertical-align:-0.3em}.md blockquote.fancyquote .author{width:100%;margin-top:10px;display:inline-block;text-align:right}.md small{font-size:60%}.md div.title,contents,.md .tocHeader,h1,h2,h3,h4,h5,h6,.md .shortTOC,.md .mediumTOC,.nonumberh1,.nonumberh2,.nonumberh3,.nonumberh4,.nonumberh5,.nonumberh6{font-family:Verdana,Helvetica,Arial,sans-serif;margin:13.4px 0 13.4px;padding:15px 0 3px;border-top:none;clear:both}.md h1,.md h2,.md h3,.md h4,.md h5,.md h6,.md .nonumberh1,.md .nonumberh2,.md .nonumberh3,.md .nonumberh4,.md .nonumberh5,.md .nonumberh6{page-break-after:avoid;break-after:avoid}.md svg.diagram{display:block;font-family:Menlo,Consolas,monospace;font-size:13.141452225px;text-align:center;stroke-linecap:round;stroke-width:2px;page-break-inside:avoid;stroke:#000;fill:#000}.md svg.diagram .opendot{fill:#FFF}.md svg.diagram text{stroke:none}@media print{.md .pagebreak{page-break-after:always;visibility:hidden}}.md a{font-family:Georgia,Palatino,'Times New Roman'}.md h1,.md .tocHeader,.md .nonumberh1{border-bottom:3px solid;font-size:20px;font-weight:bold;}.md h1,.md .nonumberh1{counter-reset: h2 h3 h4 h5 h6}.md h2,.md .nonumberh2{counter-reset: h3 h4 h5 h6;border-bottom:2px solid #999;color:#555;font-weight:bold;font-size:18px;}.md h3,.md h4,.md h5,.md h6,.md .nonumberh3,.md .nonumberh4,.md .nonumberh5,.md .nonumberh6{font-family:Helvetica,Arial,sans-serif;color:#555;font-size:16px;}.md h3{counter-reset:h4 h5 h6}.md h4{counter-reset:h5 h6}.md h5{counter-reset:h6}.md div.table{margin:16px 0 16px 0}.md table{border-collapse:collapse;line-height:140%;page-break-inside:avoid}.md table.table{margin:auto}.md table.calendar{width:100%;margin:auto;font-size:11px;font-family:Helvetica,Arial,sans-serif}.md table.calendar th{font-size:16px}.md .today{background:#ECF8FA}.md .calendar .parenthesized{color:#999;font-style:italic}.md div.tablecaption{text-align:center}.md table.table th{color:#FFF;background-color:#AAA;border:1px solid #888;padding:8px 15px 8px 15px}.md table.table td{padding:5px 15px 5px 15px;border:1px solid #888}.md table.table tr:nth-child(even){background:#EEE}.md pre.tilde{border-top: 1px solid #CCC;border-bottom: 1px solid #CCC;padding: 5px 0 5px 20px;margin:0 0 0 0;background:#FCFCFC;page-break-inside:avoid}.md a.target{width:0px;height:0px;visibility:hidden;font-size:0px;display:inline-block}.md a:link, .md a:visited{color:#38A;text-decoration:none}.md a:link:hover{text-decoration:underline}.md dt{font-weight:700}.md dl>dd{margin-top:-8px; margin-bottom:8px}.md dl>table{margin:35px 0 30px}.md code{white-space:pre;page-break-inside:avoid}.md .endnote{font-size:13px;line-height:15px;padding-left:10px;text-indent:-10px}.md .bib{padding-left:80px;text-indent:-80px;text-align:left}.markdeepFooter{font-size:9px;text-align:right;padding-top:80px;color:#999}.md .mediumTOC{float:right;font-size:12px;line-height:15px;border-left:1px solid #CCC;padding-left:15px;margin:15px 0px 15px 25px}.md .mediumTOC .level1{font-weight:600}.md .longTOC .level1{font-weight:600;display:block;padding-top:12px;margin:0 0 -20px}.md .shortTOC{text-align:center;font-weight:bold;margin-top:15px;font-size:14px}.md .admonition{position:relative;margin:1em 0;padding:.4rem 1rem;border-radius:.2rem;border-left:2.5rem solid rgba(68,138,255,.4);background-color:rgba(68,138,255,.15);}.md .admonition-title{font-weight:bold;border-bottom:solid 1px rgba(68,138,255,.4);padding-bottom:4px;margin-bottom:4px;margin-left: -1rem;padding-left:1rem;margin-right:-1rem;border-color:rgba(68,138,255,.4)}.md .admonition.tip{border-left:2.5rem solid rgba(50,255,90,.4);background-color:rgba(50,255,90,.15)}.md .admonition.tip::before{content:"\24d8";font-weight:bold;font-size:150%;position:relative;top:3px;color:rgba(26,128,46,.8);left:-2.95rem;display:block;width:0;height:0}.md .admonition.tip>.admonition-title{border-color:rgba(50,255,90,.4)}.md .admonition.warn,.md .admonition.warning{border-left:2.5rem solid rgba(255,145,0,.4);background-color:rgba(255,145,0,.15)}.md .admonition.warn::before,.md .admonition.warning::before{content:"\26A0";font-weight:bold;font-size:150%;position:relative;top:2px;color:rgba(128,73,0,.8);left:-2.95rem;display:block;width:0;height:0}.md .admonition.warn>.admonition-title,.md .admonition.warning>.admonition-title{border-color:rgba(255,145,0,.4)}.md .admonition.error{border-left: 2.5rem solid rgba(255,23,68,.4);background-color:rgba(255,23,68,.15)}.md .admonition.error>.admonition-title{border-color:rgba(255,23,68,.4)}.md .admonition.error::before{content: "\2612";font-family:"Arial";font-size:200%;position:relative;color:rgba(128,12,34,.8);top:-2px;left:-3rem;display:block;width:0;height:0}.md .admonition p:last-child{margin-bottom:0}</style><style>.md h1::before {
content:counter(h1) " ";
counter-increment: h1;margin-right:10px}.md h2::before {
content:counter(h1) "."counter(h2) " ";
counter-increment: h2;margin-right:10px}.md h3::before {
content:counter(h1) "."counter(h2) "."counter(h3) " ";
counter-increment: h3;margin-right:10px}.md h4::before {
content:counter(h1) "."counter(h2) "."counter(h3) "."counter(h4) " ";
counter-increment: h4;margin-right:10px}.md h5::before {
content:counter(h1) "."counter(h2) "."counter(h3) "."counter(h4) "."counter(h5) " ";
counter-increment: h5;margin-right:10px}.md h6::before {
content:counter(h1) "."counter(h2) "."counter(h3) "."counter(h4) "."counter(h5) "."counter(h6) " ";
counter-increment: h6;margin-right:10px}</style><style>.hljs{display:block;overflow-x:auto;padding:0.5em;background:#fff;color:#000;-webkit-text-size-adjust:none}.hljs-comment{color:#006a00}.hljs-keyword{color:#02E}.hljs-literal,.nginx .hljs-title{color:#aa0d91}.method,.hljs-list .hljs-title,.hljs-tag .hljs-title,.setting .hljs-value,.hljs-winutils,.tex .hljs-command,.http .hljs-title,.hljs-request,.hljs-status,.hljs-name{color:#008}.hljs-envvar,.tex .hljs-special{color:#660}.hljs-string{color:#c41a16}.hljs-tag .hljs-value,.hljs-cdata,.hljs-filter .hljs-argument,.hljs-attr_selector,.apache .hljs-cbracket,.hljs-date,.hljs-regexp{color:#080}.hljs-sub .hljs-identifier,.hljs-pi,.hljs-tag,.hljs-tag .hljs-keyword,.hljs-decorator,.ini .hljs-title,.hljs-shebang,.hljs-prompt,.hljs-hexcolor,.hljs-rule .hljs-value,.hljs-symbol,.hljs-symbol .hljs-string,.hljs-number,.css .hljs-function,.hljs-function .hljs-title,.coffeescript .hljs-attribute{color:#A0C}.hljs-function .hljs-title{font-weight:bold;color:#000}.hljs-class .hljs-title,.smalltalk .hljs-class,.hljs-type,.hljs-typename,.hljs-tag .hljs-attribute,.hljs-doctype,.hljs-class .hljs-id,.hljs-built_in,.setting,.hljs-params,.clojure .hljs-attribute{color:#5c2699}.hljs-variable{color:#3f6e74}.css .hljs-tag,.hljs-rule .hljs-property,.hljs-pseudo,.hljs-subst{color:#000}.css .hljs-class,.css .hljs-id{color:#9b703f}.hljs-value .hljs-important{color:#ff7700;font-weight:bold}.hljs-rule .hljs-keyword{color:#c5af75}.hljs-annotation,.apache .hljs-sqbracket,.nginx .hljs-built_in{color:#9b859d}.hljs-preprocessor,.hljs-preprocessor *,.hljs-pragma{color:#643820}.tex .hljs-formula{background-color:#eee;font-style:italic}.diff .hljs-header,.hljs-chunk{color:#808080;font-weight:bold}.diff .hljs-change{background-color:#bccff9}.hljs-addition{background-color:#baeeba}.hljs-deletion{background-color:#ffc8bd}.hljs-comment .hljs-doctag{font-weight:bold}.method .hljs-id{color:#000}</style>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta charset="utf-8"><script src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/626218844182568" async=""></script><script async="" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/fbevents.js"></script><script type="text/javascript" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/9557dbf16c"></script><script src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/nr-1118.js"></script><script type="text/javascript">(window.NREUM||(NREUM={})).loader_config={xpid:"VQYOUF9SCxAJVFRQAAcF"};window.NREUM||(NREUM={}),__nr_require=function(t,n,e){function r(e){if(!n[e]){var o=n[e]={exports:{}};t[e][0].call(o.exports,function(n){var o=t[e][1][n];return r(o||n)},o,o.exports)}return n[e].exports}if("function"==typeof __nr_require)return __nr_require;for(var o=0;o<e.length;o++)r(e[o]);return r}({1:[function(t,n,e){function r(t){try{s.console&&console.log(t)}catch(n){}}var o,i=t("ee"),a=t(16),s={};try{o=localStorage.getItem("__nr_flags").split(","),console&&"function"==typeof console.log&&(s.console=!0,o.indexOf("dev")!==-1&&(s.dev=!0),o.indexOf("nr_dev")!==-1&&(s.nrDev=!0))}catch(c){}s.nrDev&&i.on("internal-error",function(t){r(t.stack)}),s.dev&&i.on("fn-err",function(t,n,e){r(e.stack)}),s.dev&&(r("NR AGENT IN DEVELOPMENT MODE"),r("flags: "+a(s,function(t,n){return t}).join(", ")))},{}],2:[function(t,n,e){function r(t,n,e,r,s){try{p?p-=1:o(s||new UncaughtException(t,n,e),!0)}catch(f){try{i("ierr",[f,c.now(),!0])}catch(d){}}return"function"==typeof u&&u.apply(this,a(arguments))}function UncaughtException(t,n,e){this.message=t||"Uncaught error with no additional information",this.sourceURL=n,this.line=e}function o(t,n){var e=n?null:c.now();i("err",[t,e])}var i=t("handle"),a=t(17),s=t("ee"),c=t("loader"),f=t("gos"),u=window.onerror,d=!1,l="nr@seenError",p=0;c.features.err=!0,t(1),window.onerror=r;try{throw new Error}catch(h){"stack"in h&&(t(8),t(7),"addEventListener"in window&&t(5),c.xhrWrappable&&t(9),d=!0)}s.on("fn-start",function(t,n,e){d&&(p+=1)}),s.on("fn-err",function(t,n,e){d&&!e[l]&&(f(e,l,function(){return!0}),this.thrown=!0,o(e))}),s.on("fn-end",function(){d&&!this.thrown&&p>0&&(p-=1)}),s.on("internal-error",function(t){i("ierr",[t,c.now(),!0])})},{}],3:[function(t,n,e){t("loader").features.ins=!0},{}],4:[function(t,n,e){function r(t){}if(window.performance&&window.performance.timing&&window.performance.getEntriesByType){var o=t("ee"),i=t("handle"),a=t(8),s=t(7),c="learResourceTimings",f="addEventListener",u="resourcetimingbufferfull",d="bstResource",l="resource",p="-start",h="-end",m="fn"+p,v="fn"+h,w="bstTimer",y="pushState",g=t("loader");g.features.stn=!0,t(6);var b=NREUM.o.EV;o.on(m,function(t,n){var e=t[0];e instanceof b&&(this.bstStart=g.now())}),o.on(v,function(t,n){var e=t[0];e instanceof b&&i("bst",[e,n,this.bstStart,g.now()])}),a.on(m,function(t,n,e){this.bstStart=g.now(),this.bstType=e}),a.on(v,function(t,n){i(w,[n,this.bstStart,g.now(),this.bstType])}),s.on(m,function(){this.bstStart=g.now()}),s.on(v,function(t,n){i(w,[n,this.bstStart,g.now(),"requestAnimationFrame"])}),o.on(y+p,function(t){this.time=g.now(),this.startPath=location.pathname+location.hash}),o.on(y+h,function(t){i("bstHist",[location.pathname+location.hash,this.startPath,this.time])}),f in window.performance&&(window.performance["c"+c]?window.performance[f](u,function(t){i(d,[window.performance.getEntriesByType(l)]),window.performance["c"+c]()},!1):window.performance[f]("webkit"+u,function(t){i(d,[window.performance.getEntriesByType(l)]),window.performance["webkitC"+c]()},!1)),document[f]("scroll",r,{passive:!0}),document[f]("keypress",r,!1),document[f]("click",r,!1)}},{}],5:[function(t,n,e){function r(t){for(var n=t;n&&!n.hasOwnProperty(u);)n=Object.getPrototypeOf(n);n&&o(n)}function o(t){s.inPlace(t,[u,d],"-",i)}function i(t,n){return t[1]}var a=t("ee").get("events"),s=t(19)(a,!0),c=t("gos"),f=XMLHttpRequest,u="addEventListener",d="removeEventListener";n.exports=a,"getPrototypeOf"in Object?(r(document),r(window),r(f.prototype)):f.prototype.hasOwnProperty(u)&&(o(window),o(f.prototype)),a.on(u+"-start",function(t,n){var e=t[1],r=c(e,"nr@wrapped",function(){function t(){if("function"==typeof e.handleEvent)return e.handleEvent.apply(e,arguments)}var n={object:t,"function":e}[typeof e];return n?s(n,"fn-",null,n.name||"anonymous"):e});this.wrapped=t[1]=r}),a.on(d+"-start",function(t){t[1]=this.wrapped||t[1]})},{}],6:[function(t,n,e){var r=t("ee").get("history"),o=t(19)(r);n.exports=r,o.inPlace(window.history,["pushState","replaceState"],"-")},{}],7:[function(t,n,e){var r=t("ee").get("raf"),o=t(19)(r),i="equestAnimationFrame";n.exports=r,o.inPlace(window,["r"+i,"mozR"+i,"webkitR"+i,"msR"+i],"raf-"),r.on("raf-start",function(t){t[0]=o(t[0],"fn-")})},{}],8:[function(t,n,e){function r(t,n,e){t[0]=a(t[0],"fn-",null,e)}function o(t,n,e){this.method=e,this.timerDuration=isNaN(t[1])?0:+t[1],t[0]=a(t[0],"fn-",this,e)}var i=t("ee").get("timer"),a=t(19)(i),s="setTimeout",c="setInterval",f="clearTimeout",u="-start",d="-";n.exports=i,a.inPlace(window,[s,"setImmediate"],s+d),a.inPlace(window,[c],c+d),a.inPlace(window,[f,"clearImmediate"],f+d),i.on(c+u,r),i.on(s+u,o)},{}],9:[function(t,n,e){function r(t,n){d.inPlace(n,["onreadystatechange"],"fn-",s)}function o(){var t=this,n=u.context(t);t.readyState>3&&!n.resolved&&(n.resolved=!0,u.emit("xhr-resolved",[],t)),d.inPlace(t,y,"fn-",s)}function i(t){g.push(t),h&&(x?x.then(a):v?v(a):(E=-E,O.data=E))}function a(){for(var t=0;t<g.length;t++)r([],g[t]);g.length&&(g=[])}function s(t,n){return n}function c(t,n){for(var e in t)n[e]=t[e];return n}t(5);var f=t("ee"),u=f.get("xhr"),d=t(19)(u),l=NREUM.o,p=l.XHR,h=l.MO,m=l.PR,v=l.SI,w="readystatechange",y=["onload","onerror","onabort","onloadstart","onloadend","onprogress","ontimeout"],g=[];n.exports=u;var b=window.XMLHttpRequest=function(t){var n=new p(t);try{u.emit("new-xhr",[n],n),n.addEventListener(w,o,!1)}catch(e){try{u.emit("internal-error",[e])}catch(r){}}return n};if(c(p,b),b.prototype=p.prototype,d.inPlace(b.prototype,["open","send"],"-xhr-",s),u.on("send-xhr-start",function(t,n){r(t,n),i(n)}),u.on("open-xhr-start",r),h){var x=m&&m.resolve();if(!v&&!m){var E=1,O=document.createTextNode(E);new h(a).observe(O,{characterData:!0})}}else f.on("fn-end",function(t){t[0]&&t[0].type===w||a()})},{}],10:[function(t,n,e){function r(t){var n=this.params,e=this.metrics;if(!this.ended){this.ended=!0;for(var r=0;r<d;r++)t.removeEventListener(u[r],this.listener,!1);if(!n.aborted){if(e.duration=a.now()-this.startTime,4===t.readyState){n.status=t.status;var i=o(t,this.lastSize);if(i&&(e.rxSize=i),this.sameOrigin){var c=t.getResponseHeader("X-NewRelic-App-Data");c&&(n.cat=c.split(", ").pop())}}else n.status=0;e.cbTime=this.cbTime,f.emit("xhr-done",[t],t),s("xhr",[n,e,this.startTime])}}}function o(t,n){var e=t.responseType;if("json"===e&&null!==n)return n;var r="arraybuffer"===e||"blob"===e||"json"===e?t.response:t.responseText;return h(r)}function i(t,n){var e=c(n),r=t.params;r.host=e.hostname+":"+e.port,r.pathname=e.pathname,t.sameOrigin=e.sameOrigin}var a=t("loader");if(a.xhrWrappable){var s=t("handle"),c=t(11),f=t("ee"),u=["load","error","abort","timeout"],d=u.length,l=t("id"),p=t(14),h=t(13),m=window.XMLHttpRequest;a.features.xhr=!0,t(9),f.on("new-xhr",function(t){var n=this;n.totalCbs=0,n.called=0,n.cbTime=0,n.end=r,n.ended=!1,n.xhrGuids={},n.lastSize=null,p&&(p>34||p<10)||window.opera||t.addEventListener("progress",function(t){n.lastSize=t.loaded},!1)}),f.on("open-xhr-start",function(t){this.params={method:t[0]},i(this,t[1]),this.metrics={}}),f.on("open-xhr-end",function(t,n){"loader_config"in NREUM&&"xpid"in NREUM.loader_config&&this.sameOrigin&&n.setRequestHeader("X-NewRelic-ID",NREUM.loader_config.xpid)}),f.on("send-xhr-start",function(t,n){var e=this.metrics,r=t[0],o=this;if(e&&r){var i=h(r);i&&(e.txSize=i)}this.startTime=a.now(),this.listener=function(t){try{"abort"===t.type&&(o.params.aborted=!0),("load"!==t.type||o.called===o.totalCbs&&(o.onloadCalled||"function"!=typeof n.onload))&&o.end(n)}catch(e){try{f.emit("internal-error",[e])}catch(r){}}};for(var s=0;s<d;s++)n.addEventListener(u[s],this.listener,!1)}),f.on("xhr-cb-time",function(t,n,e){this.cbTime+=t,n?this.onloadCalled=!0:this.called+=1,this.called!==this.totalCbs||!this.onloadCalled&&"function"==typeof e.onload||this.end(e)}),f.on("xhr-load-added",function(t,n){var e=""+l(t)+!!n;this.xhrGuids&&!this.xhrGuids[e]&&(this.xhrGuids[e]=!0,this.totalCbs+=1)}),f.on("xhr-load-removed",function(t,n){var e=""+l(t)+!!n;this.xhrGuids&&this.xhrGuids[e]&&(delete this.xhrGuids[e],this.totalCbs-=1)}),f.on("addEventListener-end",function(t,n){n instanceof m&&"load"===t[0]&&f.emit("xhr-load-added",[t[1],t[2]],n)}),f.on("removeEventListener-end",function(t,n){n instanceof m&&"load"===t[0]&&f.emit("xhr-load-removed",[t[1],t[2]],n)}),f.on("fn-start",function(t,n,e){n instanceof m&&("onload"===e&&(this.onload=!0),("load"===(t[0]&&t[0].type)||this.onload)&&(this.xhrCbStart=a.now()))}),f.on("fn-end",function(t,n){this.xhrCbStart&&f.emit("xhr-cb-time",[a.now()-this.xhrCbStart,this.onload,n],n)})}},{}],11:[function(t,n,e){n.exports=function(t){var n=document.createElement("a"),e=window.location,r={};n.href=t,r.port=n.port;var o=n.href.split("://");!r.port&&o[1]&&(r.port=o[1].split("/")[0].split("@").pop().split(":")[1]),r.port&&"0"!==r.port||(r.port="https"===o[0]?"443":"80"),r.hostname=n.hostname||e.hostname,r.pathname=n.pathname,r.protocol=o[0],"/"!==r.pathname.charAt(0)&&(r.pathname="/"+r.pathname);var i=!n.protocol||":"===n.protocol||n.protocol===e.protocol,a=n.hostname===document.domain&&n.port===e.port;return r.sameOrigin=i&&(!n.hostname||a),r}},{}],12:[function(t,n,e){function r(){}function o(t,n,e){return function(){return i(t,[f.now()].concat(s(arguments)),n?null:this,e),n?void 0:this}}var i=t("handle"),a=t(16),s=t(17),c=t("ee").get("tracer"),f=t("loader"),u=NREUM;"undefined"==typeof window.newrelic&&(newrelic=u);var d=["setPageViewName","setCustomAttribute","setErrorHandler","finished","addToTrace","inlineHit","addRelease"],l="api-",p=l+"ixn-";a(d,function(t,n){u[n]=o(l+n,!0,"api")}),u.addPageAction=o(l+"addPageAction",!0),u.setCurrentRouteName=o(l+"routeName",!0),n.exports=newrelic,u.interaction=function(){return(new r).get()};var h=r.prototype={createTracer:function(t,n){var e={},r=this,o="function"==typeof n;return i(p+"tracer",[f.now(),t,e],r),function(){if(c.emit((o?"":"no-")+"fn-start",[f.now(),r,o],e),o)try{return n.apply(this,arguments)}catch(t){throw c.emit("fn-err",[arguments,this,t],e),t}finally{c.emit("fn-end",[f.now()],e)}}}};a("actionText,setName,setAttribute,save,ignore,onEnd,getContext,end,get".split(","),function(t,n){h[n]=o(p+n)}),newrelic.noticeError=function(t,n){"string"==typeof t&&(t=new Error(t)),i("err",[t,f.now(),!1,n])}},{}],13:[function(t,n,e){n.exports=function(t){if("string"==typeof t&&t.length)return t.length;if("object"==typeof t){if("undefined"!=typeof ArrayBuffer&&t instanceof ArrayBuffer&&t.byteLength)return t.byteLength;if("undefined"!=typeof Blob&&t instanceof Blob&&t.size)return t.size;if(!("undefined"!=typeof FormData&&t instanceof FormData))try{return JSON.stringify(t).length}catch(n){return}}}},{}],14:[function(t,n,e){var r=0,o=navigator.userAgent.match(/Firefox[\/\s](\d+\.\d+)/);o&&(r=+o[1]),n.exports=r},{}],15:[function(t,n,e){function r(t,n){if(!o)return!1;if(t!==o)return!1;if(!n)return!0;if(!i)return!1;for(var e=i.split("."),r=n.split("."),a=0;a<r.length;a++)if(r[a]!==e[a])return!1;return!0}var o=null,i=null,a=/Version\/(\S+)\s+Safari/;if(navigator.userAgent){var s=navigator.userAgent,c=s.match(a);c&&s.indexOf("Chrome")===-1&&s.indexOf("Chromium")===-1&&(o="Safari",i=c[1])}n.exports={agent:o,version:i,match:r}},{}],16:[function(t,n,e){function r(t,n){var e=[],r="",i=0;for(r in t)o.call(t,r)&&(e[i]=n(r,t[r]),i+=1);return e}var o=Object.prototype.hasOwnProperty;n.exports=r},{}],17:[function(t,n,e){function r(t,n,e){n||(n=0),"undefined"==typeof e&&(e=t?t.length:0);for(var r=-1,o=e-n||0,i=Array(o<0?0:o);++r<o;)i[r]=t[n+r];return i}n.exports=r},{}],18:[function(t,n,e){n.exports={exists:"undefined"!=typeof window.performance&&window.performance.timing&&"undefined"!=typeof window.performance.timing.navigationStart}},{}],19:[function(t,n,e){function r(t){return!(t&&t instanceof Function&&t.apply&&!t[a])}var o=t("ee"),i=t(17),a="nr@original",s=Object.prototype.hasOwnProperty,c=!1;n.exports=function(t,n){function e(t,n,e,o){function nrWrapper(){var r,a,s,c;try{a=this,r=i(arguments),s="function"==typeof e?e(r,a):e||{}}catch(f){l([f,"",[r,a,o],s])}u(n+"start",[r,a,o],s);try{return c=t.apply(a,r)}catch(d){throw u(n+"err",[r,a,d],s),d}finally{u(n+"end",[r,a,c],s)}}return r(t)?t:(n||(n=""),nrWrapper[a]=t,d(t,nrWrapper),nrWrapper)}function f(t,n,o,i){o||(o="");var a,s,c,f="-"===o.charAt(0);for(c=0;c<n.length;c++)s=n[c],a=t[s],r(a)||(t[s]=e(a,f?s+o:o,i,s))}function u(e,r,o){if(!c||n){var i=c;c=!0;try{t.emit(e,r,o,n)}catch(a){l([a,e,r,o])}c=i}}function d(t,n){if(Object.defineProperty&&Object.keys)try{var e=Object.keys(t);return e.forEach(function(e){Object.defineProperty(n,e,{get:function(){return t[e]},set:function(n){return t[e]=n,n}})}),n}catch(r){l([r])}for(var o in t)s.call(t,o)&&(n[o]=t[o]);return n}function l(n){try{t.emit("internal-error",n)}catch(e){}}return t||(t=o),e.inPlace=f,e.flag=a,e}},{}],ee:[function(t,n,e){function r(){}function o(t){function n(t){return t&&t instanceof r?t:t?c(t,s,i):i()}function e(e,r,o,i){if(!l.aborted||i){t&&t(e,r,o);for(var a=n(o),s=m(e),c=s.length,f=0;f<c;f++)s[f].apply(a,r);var d=u[g[e]];return d&&d.push([b,e,r,a]),a}}function p(t,n){y[t]=m(t).concat(n)}function h(t,n){var e=y[t];if(e)for(var r=0;r<e.length;r++)e[r]===n&&e.splice(r,1)}function m(t){return y[t]||[]}function v(t){return d[t]=d[t]||o(e)}function w(t,n){f(t,function(t,e){n=n||"feature",g[e]=n,n in u||(u[n]=[])})}var y={},g={},b={on:p,addEventListener:p,removeEventListener:h,emit:e,get:v,listeners:m,context:n,buffer:w,abort:a,aborted:!1};return b}function i(){return new r}function a(){(u.api||u.feature)&&(l.aborted=!0,u=l.backlog={})}var s="nr@context",c=t("gos"),f=t(16),u={},d={},l=n.exports=o();l.backlog=u},{}],gos:[function(t,n,e){function r(t,n,e){if(o.call(t,n))return t[n];var r=e();if(Object.defineProperty&&Object.keys)try{return Object.defineProperty(t,n,{value:r,writable:!0,enumerable:!1}),r}catch(i){}return t[n]=r,r}var o=Object.prototype.hasOwnProperty;n.exports=r},{}],handle:[function(t,n,e){function r(t,n,e,r){o.buffer([t],r),o.emit(t,n,e)}var o=t("ee").get("handle");n.exports=r,r.ee=o},{}],id:[function(t,n,e){function r(t){var n=typeof t;return!t||"object"!==n&&"function"!==n?-1:t===window?0:a(t,i,function(){return o++})}var o=1,i="nr@id",a=t("gos");n.exports=r},{}],loader:[function(t,n,e){function r(){if(!E++){var t=x.info=NREUM.info,n=p.getElementsByTagName("script")[0];if(setTimeout(u.abort,3e4),!(t&&t.licenseKey&&t.applicationID&&n))return u.abort();f(g,function(n,e){t[n]||(t[n]=e)}),c("mark",["onload",a()+x.offset],null,"api");var e=p.createElement("script");e.src="https://"+t.agent,n.parentNode.insertBefore(e,n)}}function o(){"complete"===p.readyState&&i()}function i(){c("mark",["domContent",a()+x.offset],null,"api")}function a(){return O.exists&&performance.now?Math.round(performance.now()):(s=Math.max((new Date).getTime(),s))-x.offset}var s=(new Date).getTime(),c=t("handle"),f=t(16),u=t("ee"),d=t(15),l=window,p=l.document,h="addEventListener",m="attachEvent",v=l.XMLHttpRequest,w=v&&v.prototype;NREUM.o={ST:setTimeout,SI:l.setImmediate,CT:clearTimeout,XHR:v,REQ:l.Request,EV:l.Event,PR:l.Promise,MO:l.MutationObserver};var y=""+location,g={beacon:"bam.nr-data.net",errorBeacon:"bam.nr-data.net",agent:"js-agent.newrelic.com/nr-1118.min.js"},b=v&&w&&w[h]&&!/CriOS/.test(navigator.userAgent),x=n.exports={offset:s,now:a,origin:y,features:{},xhrWrappable:b,userAgent:d};t(12),p[h]?(p[h]("DOMContentLoaded",i,!1),l[h]("load",r,!1)):(p[m]("onreadystatechange",o),l[m]("onload",r)),c("mark",["firstbyte",s],null,"api");var E=0,O=t(18)},{}]},{},["loader",2,10,4,3]);</script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<script src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/auth0.js"></script>
<script src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/dz-auth.js"></script>
<link rel="shortcut icon" href="https://developer.nvidia.com/sites/all/themes/devzone_base/favicon.ico" type="image/vnd.microsoft.icon">
<meta name="description" content="By Martin-Karl Lefrançois and Pascal Gautron The focus of this document and the provided code is to showcase a basic integration of ray tracing within an existing Vulkan sample, using the `VK_NV_ray_tracing` extension. Note that for educational purposes all the code is contained in a very small set of files. A real integration would require additional levels of abstraction.">
<meta name="generator" content="Drupal 7 (http://drupal.org)">
<link rel="canonical" href="https://developer.nvidia.com/rtx/raytracing/vkray">
<link rel="shortlink" href="https://developer.nvidia.com/node/881006">
<meta property="og:site_name" content="NVIDIA Developer">
<meta property="og:type" content="article">
<meta property="og:url" content="https://developer.nvidia.com/rtx/raytracing/vkray">
<meta property="og:title" content="NVIDIA Vulkan Ray Tracing Tutorial">
<meta property="og:description" content="By Martin-Karl Lefrançois and Pascal Gautron The focus of this document and the provided code is to showcase a basic integration of ray tracing within an existing Vulkan sample, using the `VK_NV_ray_tracing` extension. Note that for educational purposes all the code is contained in a very small set of files. A real integration would require additional levels of abstraction.  [//]: # This may be the most platform independent comment">
<meta property="og:updated_time" content="2019-02-06T15:44:22-08:00">
<meta property="article:published_time" content="2019-01-23T16:39:03-08:00">
<meta property="article:modified_time" content="2019-02-06T15:44:22-08:00">
  <title>NVIDIA Vulkan Ray Tracing Tutorial | NVIDIA Developer</title>
  <link type="text/css" rel="stylesheet" href="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/css_lQaZfjVpwP_oGNqdtWCSpJT1EMqXdMiU84ekLLxQnc4.css" media="all">
<link type="text/css" rel="stylesheet" href="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/css_hTLrwzbU9bZhjvzx-j5entbJFEHkjJyd6RgHEla8FhA.css" media="all">
<link type="text/css" rel="stylesheet" href="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/css_VWGhZkkR4B4tMJA7PC_wov8dAxaI-MS03BCM3K8jjJA.css" media="screen">
<link type="text/css" rel="stylesheet" href="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/css_SszGAe6JK9B9hacWsnKVSEo-uYCROkU91NHCZszWJpU.css" media="all">
<link type="text/css" rel="stylesheet" href="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/css_jENQOQqZCRFGZK__DTefxYiXR2RUf03k1ugj3_Vg7vk.css" media="all">
<link type="text/css" rel="stylesheet" href="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/dz-auth.css" media="all">
<link type="text/css" rel="stylesheet" href="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/css_dxTC2SnbUQpi6ay7fqSk9MkxtE4JRKtOHqpCvu7mKNQ.css" media="all">
<link type="text/css" rel="stylesheet" href="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/css_B_NZa24anRJpwDA-OiKkHdf60CQeBMGVuFfr3kbAjlA.css" media="all">
  <!-- HTML5 element support for IE6-8 -->
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <script src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/js_WOGchOeZR2luOEnZVWbQ_qLVSzcOvQMIcgzquLO8-QU.js"></script>
<script src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/js_oZD9-WvfiElJ5KPavqu9ZAQiZcfWlzNCzxFHpedR9dI.js"></script>
<script src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/satelliteLib-7ba51e58dc61bcb0e9311aadd02a0108ab24cc6c.js"></script>
<script src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/js_JP3TlCqKqiqPuAoTWfdvYhA4HjA1QSa33gLy1Yy6iPA.js"></script>
<script src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/js_oRBVbrZV7FAqu356imAriqUbp3bcQkSf7vs-78D-bp8.js"></script>
<script src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/js_qoMmK0q_AjEZdf24SPQxGHYDy4d2mzXU_yewfRUIK5Y.js"></script>
<script>jQuery.extend(Drupal.settings, {"basePath":"\/","pathPrefix":"","ajaxPageState":{"theme":"devzone_base","theme_token":"Nt2VZU2rnjUzlkLfiFWAhtBawG5V-0sXc_a9OVeSoMM","js":{"0":1,"1":1,"sites\/all\/themes\/bootstrap\/js\/bootstrap.js":1,"sites\/all\/modules\/contrib\/jquery_update\/replace\/jquery\/1.10\/jquery.min.js":1,"misc\/jquery.once.js":1,"misc\/drupal.js":1,"sites\/all\/modules\/contrib\/jquery_update\/replace\/ui\/ui\/minified\/jquery.ui.core.min.js":1,"sites\/all\/modules\/contrib\/jquery_update\/replace\/ui\/ui\/minified\/jquery.ui.widget.min.js":1,"sites\/all\/modules\/contrib\/jquery_update\/replace\/ui\/ui\/minified\/jquery.ui.position.min.js":1,"sites\/all\/modules\/contrib\/jquery_update\/replace\/ui\/ui\/minified\/jquery.ui.menu.min.js":1,"sites\/all\/modules\/contrib\/jquery_update\/replace\/ui\/ui\/minified\/jquery.ui.autocomplete.min.js":1,"\/\/assets.adobedtm.com\/b92787824f2e0e9b68dc2e993f9bd995339fe417\/satelliteLib-7ba51e58dc61bcb0e9311aadd02a0108ab24cc6c.js":1,"sites\/all\/modules\/contrib\/codefilter\/codefilter.js":1,"sites\/all\/modules\/contrib\/gss\/scripts\/autocomplete.js":1,"sites\/all\/libraries\/colorbox\/jquery.colorbox-min.js":1,"sites\/all\/modules\/contrib\/colorbox\/js\/colorbox.js":1,"sites\/all\/modules\/contrib\/hint\/hint.js":1,"sites\/all\/themes\/devzone_base\/js\/jquery.migrate.min.js":1,"sites\/all\/themes\/devzone_base\/js\/jquery.isotope.js":1,"sites\/all\/themes\/devzone_base\/js\/jquery.sidr.js":1,"sites\/all\/themes\/devzone_base\/js\/application.js":1,"sites\/all\/themes\/devzone_base\/js\/scripts.js":1,"sites\/all\/themes\/devzone_base\/js\/adroll.js":1,"sites\/all\/themes\/devzone_base\/bootstrap\/js\/affix.js":1,"sites\/all\/themes\/devzone_base\/bootstrap\/js\/alert.js":1,"sites\/all\/themes\/devzone_base\/bootstrap\/js\/button.js":1,"sites\/all\/themes\/devzone_base\/bootstrap\/js\/carousel.js":1,"sites\/all\/themes\/devzone_base\/bootstrap\/js\/collapse.js":1,"sites\/all\/themes\/devzone_base\/bootstrap\/js\/dropdown.js":1,"sites\/all\/themes\/devzone_base\/bootstrap\/js\/modal.js":1,"sites\/all\/themes\/devzone_base\/bootstrap\/js\/tooltip.js":1,"sites\/all\/themes\/devzone_base\/bootstrap\/js\/popover.js":1,"sites\/all\/themes\/devzone_base\/bootstrap\/js\/scrollspy.js":1,"sites\/all\/themes\/devzone_base\/bootstrap\/js\/tab.js":1,"sites\/all\/themes\/devzone_base\/bootstrap\/js\/transition.js":1},"css":{"modules\/system\/system.base.css":1,"misc\/ui\/jquery.ui.core.css":1,"misc\/ui\/jquery.ui.theme.css":1,"misc\/ui\/jquery.ui.menu.css":1,"misc\/ui\/jquery.ui.autocomplete.css":1,"sites\/all\/modules\/contrib\/codefilter\/codefilter.css":1,"sites\/all\/modules\/contrib\/date\/date_api\/date.css":1,"sites\/all\/modules\/contrib\/date\/date_popup\/themes\/datepicker.1.7.css":1,"sites\/all\/modules\/contrib\/date\/date_repeat_field\/date_repeat_field.css":1,"modules\/field\/theme\/field.css":1,"modules\/node\/node.css":1,"sites\/all\/modules\/contrib\/views\/css\/views.css":1,"sites\/all\/modules\/contrib\/ctools\/css\/ctools.css":1,"https:\/\/developer.nvidia.com\/register\/dz-auth.css?v=3.2.5c":1,"sites\/all\/modules\/contrib\/addtoany\/addtoany.css":1,"sites\/all\/themes\/bootstrap\/css\/overrides.css":1,"sites\/all\/themes\/devzone_base\/css\/application.css":1}},"colorbox":{"opacity":"0.85","current":"{current} of {total}","previous":"\u00ab Prev","next":"Next \u00bb","close":"Close","maxWidth":"98%","maxHeight":"98%","fixed":true,"mobiledetect":true,"mobiledevicewidth":"480px"},"gss":{"key":"000841979776854404513:41w2zzjvamy"},"urlIsAjaxTrusted":{"\/rtx\/raytracing\/vkray":true},"bootstrap":{"anchorsFix":1,"anchorsSmoothScrolling":1,"formHasError":1,"popoverEnabled":1,"popoverOptions":{"animation":1,"html":0,"placement":"right","selector":"","trigger":"click","triggerAutoclose":1,"title":"","content":"","delay":0,"container":"body"},"tooltipEnabled":1,"tooltipOptions":{"animation":1,"html":0,"placement":"auto left","selector":"","trigger":"hover focus","delay":0,"container":"body"}}});</script>
<script type="text/x-mathjax-config;executed=true">MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "AMS"} } });</script><span style="display:none">$$\newcommand{\n}{\hat{n}}\newcommand{\w}{\hat{\omega}}\newcommand{\wi}{\w_\mathrm{i}}\newcommand{\wo}{\w_\mathrm{o}}\newcommand{\wh}{\w_\mathrm{h}}\newcommand{\Li}{L_\mathrm{i}}\newcommand{\Lo}{L_\mathrm{o}}\newcommand{\Le}{L_\mathrm{e}}\newcommand{\Lr}{L_\mathrm{r}}\newcommand{\Lt}{L_\mathrm{t}}\newcommand{\O}{\mathrm{O}}\newcommand{\degrees}{{^{\large\circ}}}\newcommand{\T}{\mathsf{T}}\newcommand{\mathset}[1]{\mathbb{#1}}\newcommand{\Real}{\mathset{R}}\newcommand{\Integer}{\mathset{Z}}\newcommand{\Boolean}{\mathset{B}}\newcommand{\Complex}{\mathset{C}}\newcommand{\un}[1]{\,\mathrm{#1}}$$
</span>
<script type="text/javascript" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/MathJax.js"></script><script src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/satellite-5b9b547a64746d6c84000d75.js"></script><script src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/satellite-5a2a191764746d7d40012cac.js"></script><script src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/satellite-598bf07e64746d066f0018eb.js"></script><script src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/satellite-599197ca64746d2c22002eb4.js"></script><script src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/satellite-594a6ce764746d506700c2a3.js"></script><script src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/satellite-5991afef64746d6deb010d48.js"></script><script src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/satellite-5991b02f64746d63240018f2.js"></script><script src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/s-code-contents-72887b31a9638f8b3cff7981a426c38c354f6412.js"></script><style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 5px 0px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; -khtml-border-radius: 5px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 1px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: .7em}
.MathJax_MenuRadioCheck.RTL {right: .7em; left: auto}
.MathJax_MenuLabel {padding: 1px 2em 3px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #DDDDDD; margin: 4px 3px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: #606872; color: white}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1px; bottom: 2px; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style><style type="text/css">.MathJax_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}
.MathJax .merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MathJax .MJX-monospace {font-family: monospace}
.MathJax .MJX-sans-serif {font-family: sans-serif}
#MathJax_Tooltip {background-color: InfoBackground; color: InfoText; border: 1px solid black; box-shadow: 2px 2px 5px #AAAAAA; -webkit-box-shadow: 2px 2px 5px #AAAAAA; -moz-box-shadow: 2px 2px 5px #AAAAAA; -khtml-box-shadow: 2px 2px 5px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true'); padding: 3px 4px; z-index: 401; position: absolute; left: 0; top: 0; width: auto; height: auto; display: none}
.MathJax {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}
.MathJax:focus, body :focus .MathJax {display: inline-table}
.MathJax.MathJax_FullWidth {text-align: center; display: table-cell!important; width: 10000em!important}
.MathJax img, .MathJax nobr, .MathJax a {border: 0; padding: 0; margin: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; vertical-align: 0; line-height: normal; text-decoration: none}
img.MathJax_strut {border: 0!important; padding: 0!important; margin: 0!important; vertical-align: 0!important}
.MathJax span {display: inline; position: static; border: 0; padding: 0; margin: 0; vertical-align: 0; line-height: normal; text-decoration: none}
.MathJax nobr {white-space: nowrap!important}
.MathJax img {display: inline!important; float: none!important}
.MathJax * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}
.MathJax_Processing {visibility: hidden; position: fixed; width: 0; height: 0; overflow: hidden}
.MathJax_Processed {display: none!important}
.MathJax_ExBox {display: block!important; overflow: hidden; width: 1px; height: 60ex; min-height: 0; max-height: none}
.MathJax .MathJax_EmBox {display: block!important; overflow: hidden; width: 1px; height: 60em; min-height: 0; max-height: none}
.MathJax_LineBox {display: table!important}
.MathJax_LineBox span {display: table-cell!important; width: 10000em!important; min-width: 0; max-width: none; padding: 0; border: 0; margin: 0}
.MathJax .MathJax_HitBox {cursor: text; background: white; opacity: 0; filter: alpha(opacity=0)}
.MathJax .MathJax_HitBox * {filter: none; opacity: 1; background: transparent}
#MathJax_Tooltip * {filter: none; opacity: 1; background: transparent}
@font-face {font-family: MathJax_Blank; src: url('about:blank')}
.MathJax .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style><script async="true" type="text/javascript" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/roundtrip.js"></script><script type="text/javascript" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/OYZWQRQDRZCBLGX5QLLXRG.js"></script><script async="true" type="text/javascript" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/XDTCNQ3C2NF3DKOAMKYLNF"></script><div style="width: 1px; height: 1px; display: inline; position: absolute;"><img style="border-style:none;" alt="" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/out_005.gif" width="1" height="1"><img style="border-style:none;" alt="" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/out_012.gif" width="1" height="1"><img style="border-style:none;" alt="" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/out_008.gif" width="1" height="1"><img style="border-style:none;" alt="" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/out_007.gif" width="1" height="1"><img style="border-style:none;" alt="" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/out_013.gif" width="1" height="1"><img style="border-style:none;" alt="" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/out_010.gif" width="1" height="1"><img style="border-style:none;" alt="" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/out_011.gif" width="1" height="1"></div><div style="width: 1px; height: 1px; display: inline; position: absolute;"><img style="border-style:none;" alt="" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/out_009.gif" width="1" height="1">
<img style="border-style:none;" alt="" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/out_003.gif" width="1" height="1">
<img style="border-style:none;" alt="" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/out_002.gif" width="1" height="1">
<img style="border-style:none;" alt="" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/out_004.gif" width="1" height="1">
<img style="border-style:none;" alt="" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/out_006.gif" width="1" height="1">
<img style="border-style:none;" alt="" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/out.gif" width="1" height="1">
</div></head>
<body class="html not-front not-logged-in no-sidebars page-node page-node- page-node-881006 node-type-page published"><div style="visibility: hidden; overflow: hidden; position: absolute; top: 0px; height: 1px; width: auto; padding: 0px; border: 0px none; margin: 0px; text-align: left; text-indent: 0px; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal;"><div id="MathJax_Hidden"></div></div><div id="MathJax_Message" style="display: none;"></div>
  <div id="skip-link">
    <a href="#main-content" class="element-invisible element-focusable">Skip to main content</a>
  </div>
    

<!--Navbar-->
<nav class="navbar navbar-inverse navbar-static-top" role="navigation" id="nvidia-dropdown">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle" type="button"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button>
      <div class="logo-header">
        <a class="navbar-brand first-logo" href="https://developer.nvidia.com/" title="Home">
          <img alt="Home" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/nvidia.png">
        </a>
        <a class="navbar-brand second-logo" href="https://developer.nvidia.com/" title="Home">
          <img alt="Home" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/logo.png">
        </a>
      </div>
    </div>
    <div class="collapse navbar-collapse" id="navbar-collapse">

              <ul class="menu nav navbar-nav"><li class="first leaf"><a href="http://news.developer.nvidia.com/" title="">NEWS</a></li>
<li class="leaf"><a href="https://devblogs.nvidia.com/" title="">BLOG</a></li>
<li class="last leaf"><a href="https://devtalk.nvidia.com/" title="">FORUMS</a></li>
</ul>            <ul class="nav navbar-nav navbar-margin navbar-right navbar-margin-media login-nav">
                  <li class="search" id="search-top">
            <div class="search-form" id="search-top-form">
              <form class="gss form-search content-search" action="/rtx/raytracing/vkray" method="post" id="search-block-form" accept-charset="UTF-8"><div><div>
      <h2 class="element-invisible">Search form</h2>
    <div class="input-group"><input title="Enter the terms you wish to search for." placeholder="Search..." class="form-control form-text" type="text" id="edit-search-block-form--2" name="search_block_form" size="15" maxlength="128"><span class="input-group-btn"><button type="submit" class="btn btn-default"><span class="icon glyphicon glyphicon-search" aria-hidden="true"></span>
</button></span></div><div class="form-actions form-wrapper form-group" id="edit-actions"><button class="element-invisible btn btn-primary form-submit" type="submit" id="edit-submit" name="op" value="Search">Search</button>
</div><input type="hidden" name="form_build_id" value="form-eccIESa4-4sSuVZZGouDiPo0gDGcPRZoBp0LsTZYCK8">
<input type="hidden" name="form_id" value="search_block_form">
</div>
</div></form>            </div>
          </li>
        
        
          
                        <li class="leaf join-link" id="dzauth_register_link"><a href="javascript:jQuery.sidr('close');javascript:showDzAuth('register');">Join</a></li>
<li class="leaf last" id="dzauth_login_link"><a href="javascript:jQuery.sidr('close');javascript:showDzAuth('login');">Login</a></li>          
      </ul>
  </div>
</div>
</nav>
<nav class="navbar navbar-inverse second-navbar hidden-xs" role="navigation" id="nvidia-secondary-dropdown">
      <div class="container">
        <div class="collapse navbar-collapse">
          <ul class="menu nav navbar-nav secondary"><li class="first leaf"><a href="https://developer.nvidia.com/rtx" title="">RTX</a></li>
<li class="leaf"><a href="https://developer.nvidia.com/gameworks" title="">GAMEWORKS</a></li>
<li class="leaf"><a href="https://developer.nvidia.com/designworks" title="">DESIGNWORKS</a></li>
<li class="leaf"><a href="https://developer.nvidia.com/vrworks" title="">VRWORKS</a></li>
<li class="leaf"><a href="https://developer.nvidia.com/computeworks" title="">COMPUTEWORKS</a></li>
<li class="leaf"><a href="https://developer.nvidia.com/embedded-computing" title="">JETPACK</a></li>
<li class="leaf"><a href="https://developer.nvidia.com/drive" title="">DRIVE</a></li>
<li class="leaf"><a href="https://developer.nvidia.com/clara" title="">CLARA</a></li>
<li class="last leaf"><a href="https://developer.nvidia.com/open-source" title="">OPEN SOURCE</a></li>
</ul>                  </div>
      </div>
    </nav>

<div id="wrapper">
          
  <div id="content-background" class="white-background">
        <div id="console">
      <div class="container">
                      </div>
    </div>
    
    <div class="separator"></div>
    <div id="content" class="container">
              <ol class="breadcrumb hidden-xs"><li class="active"><a href="https://developer.nvidia.com/">Home</a></li></ol>      
                      <div class="separator"></div>
      
      
      <div class="row">

        
        <section class="col-sm-12">
                    <div class="page-header ">
            <h1 class="title">
              NVIDIA Vulkan Ray Tracing Tutorial            </h1>
          </div>
          
                    <a id="main-content"></a>

            <div class="region region-content">
    <section id="block-system-main" class="block block-system clearfix">

      
  <div class="ds-1col node node-page view-mode-full clearfix">

  
  <div class="field field-name-body field-type-text-with-summary field-label-hidden"><div class="field-items"><div class="field-item even">By <a href="https://devblogs.nvidia.com/author/mlefrancois/">Martin-Karl Lefrançois</a> and <a href="https://devblogs.nvidia.com/author/pgautron/">Pascal Gautron</a>

<div><span class="md"><p></p><p>

The focus of this document and the provided code is to showcase a basic integration of 
ray tracing within an existing Vulkan sample, using the <code>VK_NV_ray_tracing</code> extension. Note that for 
educational purposes all the code is contained in a very small set of files. A real 
integration would require additional levels of abstraction. 

</p>
<a class="target" name="environmentsetup">&nbsp;</a><h1>Environment Setup </h1>
<p>


To get support for VK_NV_ray_tracing, please install an <a href="http://www.nvidia.com/Download/index.aspx?lang=en-us">NVIDIA driver</a> with version 416.81 or later, and the <a href="http://vulkan.lunarg.com/sdk/home">Vulkan SDK</a> version 1.1.92.1 or later. 

</p><p>

The base code for the tutorial is located here: 

</p><p>

</p><div class="admonition note"><div class="admonition-title"> Base Source Code (<a href="https://developer.nvidia.com/rtx/raytracing/vkrt_helpers/files/vkexamples.zip">Download</a>)</div>

<p></p><p>

    Download the file and extract it.</p></div>

<p></p><p>

The solution contains the <code>VkExample1</code> project that provides a simple framework allowing us to load OBJ files and display them 
using Vulkan. The project compiles and runs, loading a simple OBJ file and rendering it using the regular Vulkan rasterization.

</p><p>

</p><center><a href="https://developer.nvidia.com/sites/default/files/pictures/2019/vulkan_raytracing/resultRasterCube.png" target="_blank"><img class="markdeep" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/resultRasterCube.png"></a></center>

<p></p>
<a class="target" name="vulkanraytracingutilities">&nbsp;</a><h1>Vulkan Ray Tracing Utilities</h1>
<p>

This tutorial covers the usage of the NVIDIA extension for ray tracing, <code>VK_NV_ray_tracing</code>. In the following, we will use some utility functions that are abstracting some really verbose
implementation. The implementation of those abstractions is fully documented <a href="https://developer.nvidia.com/rtx/raytracing/vkrt_helpers">here</a> and should help
 clarifying the concepts of Vulkan ray tracing. Those utilities are already present in the archive, in the <code>libs\vulkannv</code> and <code>libs\vulkannv\nv_helpers_vk</code> folders.

</p><p>

</p><ol start="1">
<li class="number">Add the utility files to the solution 
</li>
<li class="number">Select all <code>.cpp</code> of both folders and set the precompiled header flag to <code>Not Using Precompiled Headers</code>
</li>
<li class="number">Add <code>$(SolutionDir)libs\vulkannv</code> to the project include <code>C/C++&gt; General&gt; Additional Include Directories</code></li></ol>

<p></p>
<a class="target" name="gettheexistingcodetorun">&nbsp;</a><h1>Get the existing code to run</h1>
<p>


Go to the <code>main</code> function of the <code>main.cpp</code> file, find the call to <code>setupVulkan</code>. This method has a third parameter defining the extensions to activate, since Vulkan requires an explicit activation
of the extensions used by the application. Therefore, we also need to explicitly
add the <code>VK_NV_ray_tracing</code> extension:

</p><pre class="listing tilde"><code><span class="hljs-comment">// #VKRT: Activate the ray tracing extension</span>
VkCtx.setupVulkan(<span class="hljs-built_in">window</span>, <span class="hljs-literal">false</span>,
  {VK_KHR_SWAPCHAIN_EXTENSION_NAME, VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME,
   VK_KHR_MAINTENANCE3_EXTENSION_NAME, VK_NV_RAY_TRACING_EXTENSION_NAME});</code></pre>
<a class="target" name="raytracingsetup">&nbsp;</a><h1>Ray Tracing setup</h1>
<p>


In the <code>HelloVulkan</code> class, add the initialization function and a member storing the capabilities of the GPU for ray tracing:
</p><pre class="listing tilde"><code><span class="hljs-comment">// #VKRT</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initRayTracing</span><span class="hljs-params">()</span></span>;
VkPhysicalDeviceRayTracingPropertiesNV m_raytracingProperties = {};</code></pre><p>

At the end of the <code>hello_vulkan.cpp</code> file, add the body of the method, which will query the capabilities
of the GPU with respect to the ray tracing extension. In particular, it will obtain the maximum recursion depth,
ie. the number of nested ray tracing calls that can be performed from a single ray. This can be seen as the number
of times a ray can bounce in the scene in a recursive path tracer. Note that for performance purposes, recursion
should in practice be kept to a minimum, favoring a loop formulation. The shader header size will be useful when
creating the shader binding table in a later section. 
</p><pre class="listing tilde"><code><span class="hljs-comment">//--------------------------------------------------------------------------------------------------</span>
<span class="hljs-comment">// Initialize Vulkan ray tracing</span>
<span class="hljs-comment">// #VKRT</span>
<span class="hljs-keyword">void</span> HelloVulkan::initRayTracing()
{
  <span class="hljs-comment">// Query the values of shaderHeaderSize and maxRecursionDepth in current implementation</span>
  m_raytracingProperties.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV;
  m_raytracingProperties.pNext = <span class="hljs-literal">nullptr</span>;
  m_raytracingProperties.maxRecursionDepth = <span class="hljs-number">0</span>;
  m_raytracingProperties.shaderGroupHandleSize = <span class="hljs-number">0</span>;
  VkPhysicalDeviceProperties2 props;
  props.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;
  props.pNext = &amp;m_raytracingProperties;
  props.properties = {};
  vkGetPhysicalDeviceProperties2(VkCtx.getPhysicalDevice(), &amp;props);
}</code></pre>
<a class="target" name="main">&nbsp;</a><h2>main</h2>
<p>

In the <code>main.cpp</code> file, in the <code>main</code> function, call the initialization method right after  <code>helloVulkan.updateDescriptorSet();</code> 
</p><pre class="listing tilde"><code>// <span class="hljs-comment">#VKRT</span>
helloVulkan.initRayTracing();</code></pre><p>

As an exercise, when running the program, you can put a breakpoint in the <code>initRayTracing</code> method to inspect the resulting values. 
On a Titan V, the maximum recursion depth is 31, and the shader header size is 16.

</p>
<a class="target" name="accelerationstructure">&nbsp;</a><h1>Acceleration Structure</h1>
<p>


To be efficient, ray tracing requires putting the geometry in an 
acceleration structure (AS)
that will reduce the number of ray-triangle intersection tests during 
rendering. 
This structure is divided into a two-level tree. Intuitively, this can 
directly map to the notion
of an object in a scene graph, where the internal nodes of the graph 
have been collapsed into a single 
transform matrix for each bottom-level acceleration structure (BLAS) 
objects. Those BLAS then hold the actual vertex data of each object. 
However, it is
 also possible to combine multiple objects within a single bottom-level 
AS: for that, a single BLAS can be 
 built from multiple vertex buffers, each with its own transform matrix.
 Note that if an object is instantiated 
 several times within a same BLAS, its geometry will be duplicated. This
 can particularly be useful to 
 improve performance on static, non-instantiated scene components (as a 
rule of thumb, the fewer BLAS, the better). 

</p><p>

For each BLAS, the top-level AS that will contain the object instances, each one 
with its own transformation matrix. We will start with a single bottom-level AS containing 
the vertices of the triangle and a top-level AS instancing it once with an identity transform. 

</p><p>

</p><center><div class="image" style=""><a href="https://developer.nvidia.com/sites/default/files/pictures/2019/vulkan_raytracing/AccelerationStructure.svg" target="_blank"><img class="markdeep" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/AccelerationStructure.svg"></a><div class="imagecaption"><a class="target" name="figure_step">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;1:</b> Acceleration Structure</div></div></center> 

<p></p><p>

In the header file, add the includes to the helper classes for the bottom-level and top-level acceleration structures:
</p><pre class="listing tilde"><code><span class="hljs-comment">// #VKRT</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"nv_helpers_vk/BottomLevelASGenerator.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"nv_helpers_vk/TopLevelASGenerator.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"nv_helpers_vk/VKHelpers.h"</span></span></code></pre><p>

In the <code>HelloVulkan</code> class, we will introduce the notion of 
geometry instances. Those instances store the buffer handles to the 
vertex and index arrays along with
offsets in those, as well as a transform matrix:
</p><pre class="listing tilde"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GeometryInstance</span>
{</span>
  GeometryInstance(VkBuffer vBuffer, <span class="hljs-keyword">uint32_t</span> vc, VkDeviceSize vo, VkBuffer iBuffer, <span class="hljs-keyword">uint32_t</span> ic,
                   VkDeviceSize io, <span class="hljs-keyword">const</span> glm::mat4x4 &amp;t)
      : vertexBuffer(vBuffer), vertexCount(vc), vertexOffset(vo), indexBuffer(iBuffer),
        indexCount(ic), indexOffset(io), transform(t)
  {
  }
  VkBuffer vertexBuffer;
  <span class="hljs-keyword">uint32_t</span> vertexCount;
  VkDeviceSize vertexOffset;
  VkBuffer indexBuffer;
  <span class="hljs-keyword">uint32_t</span> indexCount;
  VkDeviceSize indexOffset;
  glm::mat4x4 transform;
};

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createGeometryInstances</span><span class="hljs-params">()</span></span>;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;geometryinstance&gt; m_geometryInstances;</code></pre><p>

We also declare an acceleration structure storage, which stores the handles to the buffers related to the 
acceleration structure builder: the scratch memory, the final result, and the instances definitions. 
</p><pre class="listing tilde"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AccelerationStructure</span>
</span>{
  <span class="hljs-type">VkBuffer</span> scratchBuffer = <span class="hljs-type">VK_NULL_HANDLE</span>;
  <span class="hljs-type">VkDeviceMemory</span> scratchMem = <span class="hljs-type">VK_NULL_HANDLE</span>;
  <span class="hljs-type">VkBuffer</span> resultBuffer = <span class="hljs-type">VK_NULL_HANDLE</span>;
  <span class="hljs-type">VkDeviceMemory</span> resultMem = <span class="hljs-type">VK_NULL_HANDLE</span>;
  <span class="hljs-type">VkBuffer</span> instancesBuffer = <span class="hljs-type">VK_NULL_HANDLE</span>;
  <span class="hljs-type">VkDeviceMemory</span> instancesMem = <span class="hljs-type">VK_NULL_HANDLE</span>;
  <span class="hljs-type">VkAccelerationStructureNV</span> structure = <span class="hljs-type">VK_NULL_HANDLE</span>;
};</code></pre><p>
We introduce 3 new methods as well: the builder for the bottom-level acceleration structure, the one for the top-level AS, and 
the global method <code>createAccelerationStructures</code> that will 
generate the acceleration structures for the whole scene. Note that we 
also 
add a storage for the top-level AS that will be used when calling the 
ray tracing, and we also store the helper object for the top-level AS in
 
anticipation of potential AS refitting in a further chapter. 
</p><pre class="listing tilde"><code><span class="hljs-function">AccelerationStructure <span class="hljs-title">createBottomLevelAS</span><span class="hljs-params">(
    VkCommandBuffer commandBuffer,
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;
        <span class="hljs-built_in">std</span>::tuple&lt;vkbuffer, *=<span class="hljs-string">""</span> vertex=<span class="hljs-string">""</span> buffer=<span class="hljs-string">""</span> <span class="hljs-keyword">uint32_t</span>,=<span class="hljs-string">""</span> count=<span class="hljs-string">""</span> vkdevicesize,=<span class="hljs-string">""</span> offset=<span class="hljs-string">""</span> vkbuffer,=<span class="hljs-string">""</span> index=<span class="hljs-string">""</span> vkdevicesize=<span class="hljs-string">""</span>&gt;&gt;
        vVertexBuffers)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">createTopLevelAS</span><span class="hljs-params">(VkCommandBuffer commandBuffer,
                 <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::pair&lt;vkaccelerationstructurenv, glm::mat4x4=<span class="hljs-string">""</span>&gt;&gt;&amp; instances,
                 <span class="hljs-comment">/* pair of bottom level AS and matrix of the instance */</span> VkBool32 updateOnly)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createAccelerationStructures</span><span class="hljs-params">()</span></span>;

nv_helpers_vk::TopLevelASGenerator m_topLevelASGenerator;
AccelerationStructure m_topLevelAS;</code></pre><p>

In the source file, add the code to generate the geometry instances. Since the simple OBJ loader imports the 
geometry as a single object, this method is straightforward. Using a more complex scene definition, this should
of course be extended. In particular, the instances for ray tracing cannot be used to define a full, multilevel scene
graph: the matrices would have to be combined for each instance, so that the resulting scene only contains a flat list 
of instances, each with its unique matrix. 
</p><pre class="listing tilde"><code><span class="hljs-comment">//--------------------------------------------------------------------------------------------------</span>
<span class="hljs-comment">// Create the instances from the scene data</span>
<span class="hljs-comment">// #VKRT</span>
<span class="hljs-type">void</span> HelloVulkan::createGeometryInstances()
{
  <span class="hljs-comment">// The importer always imports the geometry as a single instance, without a transform. Using a</span>
  <span class="hljs-comment">// more complex importer, this should be adapted.</span>
  glm::<span class="hljs-type">mat4x4</span> mat = glm::<span class="hljs-type">mat4x4</span>();
  m_geometryInstances.push_back(
      {m_vertexBuffer, m_nbVertices, <span class="hljs-number">0</span>, m_indexBuffer, m_nbIndices, <span class="hljs-number">0</span>, mat});
}</code></pre><p>

The next step is the construction of the bottom-level acceleration structure, that will hold the actual 
geometry of the object. This method will enqueue the construction work on a command buffer, and simply 
takes the geometry definition in the form of vertex and index arrays. Using the <code>BottomLevelASGenerator</code>
helper, we first register the geometry data:
</p><pre class="listing tilde"><code><span class="hljs-comment">//--------------------------------------------------------------------------------------------------</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Create a bottom-level acceleration structure based on a list of vertex buffers in GPU memory</span>
<span class="hljs-comment">// along with their vertex count. The build is then done in 3 steps: gathering the geometry,</span>
<span class="hljs-comment">// computing the sizes of the required buffers, and building the actual AS</span>
<span class="hljs-comment">// #VKRT</span>
HelloVulkan::AccelerationStructure
HelloVulkan::createBottomLevelAS(VkCommandBuffer commandBuffer,
                                 <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::tuple&lt;vkbuffer, vertex=<span class="hljs-string">""</span> buffer=<span class="hljs-string">""</span> <span class="hljs-keyword">uint32_t</span>,=<span class="hljs-string">""</span> count=<span class="hljs-string">""</span> vkdevicesize,=<span class="hljs-string">""</span> offset=<span class="hljs-string">""</span> vkbuffer,=<span class="hljs-string">""</span> index=<span class="hljs-string">""</span> vkdevicesize=<span class="hljs-string">""</span>&gt;&gt;
                                     vVertexBuffers)
{
  <span class="hljs-comment">// Convenient enum corresponding to the entries in the tuple</span>
  <span class="hljs-keyword">enum</span>
  {
    VERTEX_BUFFER = <span class="hljs-number">0</span>,
    VERTEX_COUNT = <span class="hljs-number">1</span>,
    VERTEX_OFFSET = <span class="hljs-number">2</span>,
    INDEX_BUFFER = <span class="hljs-number">3</span>,
    INDEX_COUNT = <span class="hljs-number">4</span>,
    INDEX_OFFSET = <span class="hljs-number">5</span>
  };

  nv_helpers_vk::BottomLevelASGenerator bottomLevelAS;

  <span class="hljs-comment">// Adding all vertex buffers and not transforming their position.</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;buffer : vVertexBuffers)
  {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">std</span>::get&lt;index_buffer&gt;(buffer) == VK_NULL_HANDLE)
    {
      <span class="hljs-comment">// No indices</span>
      bottomLevelAS.AddVertexBuffer(<span class="hljs-built_in">std</span>::get&lt;vertex_buffer&gt;(buffer),
                                    <span class="hljs-built_in">std</span>::get&lt;vertex_offset&gt;(buffer), <span class="hljs-built_in">std</span>::get&lt;vertex_count&gt;(buffer),
                                    <span class="hljs-keyword">sizeof</span>(Vertex), VK_NULL_HANDLE, <span class="hljs-number">0</span>);
    }
    <span class="hljs-keyword">else</span>
    {
      <span class="hljs-comment">// Indexed geometry</span>
      bottomLevelAS.AddVertexBuffer(
          <span class="hljs-built_in">std</span>::get&lt;vertex_buffer&gt;(buffer), <span class="hljs-built_in">std</span>::get&lt;vertex_offset&gt;(buffer),
          <span class="hljs-built_in">std</span>::get&lt;vertex_count&gt;(buffer), <span class="hljs-keyword">sizeof</span>(Vertex), <span class="hljs-built_in">std</span>::get&lt;index_buffer&gt;(buffer),
          <span class="hljs-built_in">std</span>::get&lt;index_offset&gt;(buffer), <span class="hljs-built_in">std</span>::get&lt;index_count&gt;(buffer), <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>);
    }
  }</code></pre><p>

Then we can create the handle to the acceleration structure, by internally calling <code>vkCreateAccelerationStructureNV</code>:
</p><pre class="listing tilde"><code>  AccelerationStructure buffers;

  <span class="hljs-comment">// Once the overall size of the geometry is known, we can create the handle for the acceleration</span>
  <span class="hljs-comment">// structure</span>
  buffers.structure = bottomLevelAS.CreateAccelerationStructure(VkCtx.getDevice(), <span class="hljs-literal">false</span>);</code></pre><p>

To build a bottom-level acceleration structure we need to allocate some amount of scratch memory that
will be used by the builder to process the geometry, and some memory to hold the final BLAS. Since both 
are dependent on the scene complexity, we can obtain an estimate of the required spaces by calling <code>ComputeASBufferSizes</code>, which calls
<code>vkGetAccelerationStructureMemoryRequirementsNV</code> internally. We can then allocate the buffers
according to the output values.
</p><pre class="listing tilde"><code>  <span class="hljs-comment">// The AS build requires some scratch space to store temporary information. The amount of scratch</span>
  <span class="hljs-comment">// memory is dependent on the scene complexity.</span>
  VkDeviceSize scratchSizeInBytes = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// The final AS also needs to be stored in addition to the existing vertex buffers. It size is</span>
  <span class="hljs-comment">// also dependent on the scene complexity.</span>
  VkDeviceSize resultSizeInBytes = <span class="hljs-number">0</span>;
  bottomLevelAS.ComputeASBufferSizes(VkCtx.getDevice(), buffers.structure, &amp;scratchSizeInBytes,
                                     &amp;resultSizeInBytes);

  <span class="hljs-comment">// Once the sizes are obtained, the application is responsible for allocating the necessary</span>
  <span class="hljs-comment">// buffers. Since the entire generation will be done on the GPU, we can directly allocate those on</span>
  <span class="hljs-comment">// the default heap</span>
  nv_helpers_vk::createBuffer(VkCtx.getPhysicalDevice(), VkCtx.getDevice(), scratchSizeInBytes,
                              VK_BUFFER_USAGE_RAY_TRACING_BIT_NV, &amp;buffers.scratchBuffer,
                              &amp;buffers.scratchMem, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);

  nv_helpers_vk::createBuffer(VkCtx.getPhysicalDevice(), VkCtx.getDevice(), resultSizeInBytes,
                              VK_BUFFER_USAGE_RAY_TRACING_BIT_NV, &amp;buffers.resultBuffer,
                              &amp;buffers.resultMem, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);</code></pre><p>

The BLAS can finally be built using the allocated buffers, where the <code>generate</code> call will use <code>vkBindAccelerationStructureMemoryNV</code> to bind the 
allocated memory to the AS, and <code>vkCmdBuildAccelerationStructureNV</code> will enqueue the actual build order on the command list.
</p><pre class="listing tilde"><code>  <span class="hljs-comment">// Build the acceleration structure. Note that this call integrates a barrier</span>
  <span class="hljs-comment">// on the generated AS, so that it can be used to compute a top-level AS right</span>
  <span class="hljs-comment">// after this method.</span>
  bottomLevelAS.Generate(VkCtx.getDevice(), commandBuffer, buffers.structure, buffers.scratchBuffer,
                         <span class="hljs-number">0</span>, buffers.resultBuffer, buffers.resultMem, <span class="hljs-literal">false</span>, VK_NULL_HANDLE);
  <span class="hljs-keyword">return</span> buffers;
}</code></pre><p>

The top-level acceleration structure build follows a similar scheme, but will this time take a vector
of instances defined by a bottom-level acceleration structures and a transform. This method also supports
dynamic updates that will be used in a later chapter, using the <code>updateOnly</code> flag. For now the method will always 
have this flag set to <code>false</code>, forcing a complete build of the TLAS. As for the BLAS, we first add the contents 
of the TLAS, and then create the acceleration structure handle:
</p><pre class="listing tilde"><code><span class="hljs-comment">//--------------------------------------------------------------------------------------------------</span>
<span class="hljs-comment">// Create the main acceleration structure that holds all instances of the scene. Similarly to the</span>
<span class="hljs-comment">// bottom-level AS generation, it is done in 3 steps: gathering the instances, computing the memory</span>
<span class="hljs-comment">// requirements for the AS, and building the AS itself</span>
<span class="hljs-comment">// #VKRT</span>
<span class="hljs-keyword">void</span> HelloVulkan::createTopLevelAS(
    VkCommandBuffer commandBuffer,
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::pair&lt;vkaccelerationstructurenv, glm::mat4x4=<span class="hljs-string">""</span>&gt;&gt;&amp;
        instances, <span class="hljs-comment">// pair of bottom level AS and matrix of the instance</span>
    VkBool32 updateOnly)
{
  <span class="hljs-keyword">if</span> (!updateOnly)
  {
    <span class="hljs-comment">// Gather all the instances into the builder helper</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; instances.size(); i++)
    {
      <span class="hljs-comment">// For each instance we set its instance index to its index i in the instance vector, and set</span>
      <span class="hljs-comment">// its hit group index to i. The hit group index defines which entry of the shader binding</span>
      <span class="hljs-comment">// table will contain the hit group to be executed when hitting this instance. We set this</span>
      <span class="hljs-comment">// index to i due to the use of only one type of ray in the scene</span>
      m_topLevelASGenerator.AddInstance(instances[i].first, instances[i].second,
                                        <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(i), <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(i));
    }

    <span class="hljs-comment">// Once all instances have been added, we can create the handle for the TLAS</span>
    m_topLevelAS.structure =
        m_topLevelASGenerator.CreateAccelerationStructure(VkCtx.getDevice(), VK_TRUE);</code></pre><p>

We can then estimate the memory requirements for the build similarly to the BLAS. However, we now have an 
additional buffer that will store the definition of the instances:
</p><pre class="listing tilde"><code>    <span class="hljs-comment">// As for the bottom-level AS, the building the AS requires some scratch space to store</span>
    <span class="hljs-comment">// temporary data in addition to the actual AS. In the case of the top-level AS, the instance</span>
    <span class="hljs-comment">// descriptors also need to be stored in GPU memory. This call outputs the memory requirements</span>
    <span class="hljs-comment">// for each (scratch, results, instance descriptors) so that the application can allocate the</span>
    <span class="hljs-comment">// corresponding memory</span>
    VkDeviceSize scratchSizeInBytes, resultSizeInBytes, instanceDescsSizeInBytes;
    m_topLevelASGenerator.ComputeASBufferSizes(VkCtx.getDevice(), m_topLevelAS.structure,
                                               &amp;scratchSizeInBytes, &amp;resultSizeInBytes,
                                               &amp;instanceDescsSizeInBytes);

    <span class="hljs-comment">// Create the scratch and result buffers. Since the build is all done on GPU, those can be</span>
    <span class="hljs-comment">// allocated on the default heap</span>
    nv_helpers_vk::createBuffer(VkCtx.getPhysicalDevice(), VkCtx.getDevice(), scratchSizeInBytes,
                                VK_BUFFER_USAGE_RAY_TRACING_BIT_NV, &amp;m_topLevelAS.scratchBuffer,
                                &amp;m_topLevelAS.scratchMem, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);

    nv_helpers_vk::createBuffer(VkCtx.getPhysicalDevice(), VkCtx.getDevice(), resultSizeInBytes,
                                VK_BUFFER_USAGE_RAY_TRACING_BIT_NV, &amp;m_topLevelAS.resultBuffer,
                                &amp;m_topLevelAS.resultMem, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);
    <span class="hljs-comment">// The buffer describing the instances: ID, shader binding information, matrices ... Those will</span>
    <span class="hljs-comment">// be copied into the buffer by the helper through mapping, so the buffer has to be allocated on</span>
    <span class="hljs-comment">// the upload heap.</span>

    nv_helpers_vk::createBuffer(VkCtx.getPhysicalDevice(), VkCtx.getDevice(),
                                instanceDescsSizeInBytes, VK_BUFFER_USAGE_RAY_TRACING_BIT_NV,
                                &amp;m_topLevelAS.instancesBuffer, &amp;m_topLevelAS.instancesMem,
                                VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
                                    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);
  }</code></pre><p>

From the instances definitions and the allocated buffers, we can now call the generation method that will use
<code>vkCmdBuildAccelerationStructureNV</code> to enqueue the AS build on the command buffer:
</p><pre class="listing tilde"><code>  <span class="hljs-comment">// After all the buffers are allocated, or if only an update is required, we can build the</span>
  <span class="hljs-comment">// acceleration structure. Note that in the case of the update we also pass the existing AS as the</span>
  <span class="hljs-comment">// 'previous' AS, so that it can be refitted in place.</span>
  <span class="hljs-comment">// Build the acceleration structure. Note that this call integrates a barrier</span>
  <span class="hljs-comment">// on the generated AS, so that it can be used to compute a top-level AS right</span>
  <span class="hljs-comment">// after this method.</span>
  m_topLevelASGenerator.Generate(
      VkCtx.getDevice(), commandBuffer, m_topLevelAS.structure, m_topLevelAS.scratchBuffer, <span class="hljs-number">0</span>,
      m_topLevelAS.resultBuffer, m_topLevelAS.resultMem, m_topLevelAS.instancesBuffer,
      m_topLevelAS.instancesMem, updateOnly, updateOnly ? m_topLevelAS.structure : VK_NULL_HANDLE);
}</code></pre><p>

Using the above methods, we can implement the construction of the full scene representation for ray tracing.
Since the builder calls require a command buffer, we allocate one that will only be used for that purpose:
</p><pre class="listing tilde"><code><span class="hljs-comment">//--------------------------------------------------------------------------------------------------</span>
<span class="hljs-comment">// Create the bottom-level and top-level acceleration structures</span>
<span class="hljs-comment">// #VKRT</span>
<span class="hljs-keyword">void</span> HelloVulkan::createAccelerationStructures()
{

  <span class="hljs-comment">// Create a one-time command buffer in which the AS build commands will be issued</span>
  VkCommandBufferAllocateInfo commandBufferAllocateInfo;
  commandBufferAllocateInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
  commandBufferAllocateInfo.pNext = <span class="hljs-literal">nullptr</span>;
  commandBufferAllocateInfo.commandPool = VkCtx.getCommandPool()[VkCtx.getFrameIndex()];
  commandBufferAllocateInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
  commandBufferAllocateInfo.commandBufferCount = <span class="hljs-number">1</span>;

  VkCommandBuffer commandBuffer = VK_NULL_HANDLE;
  VkResult code =
      vkAllocateCommandBuffers(VkCtx.getDevice(), &amp;commandBufferAllocateInfo, &amp;commandBuffer);
  <span class="hljs-keyword">if</span> (code != VK_SUCCESS)
  {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::logic_error(<span class="hljs-string">"rt vkAllocateCommandBuffers failed"</span>);
  }

  VkCommandBufferBeginInfo beginInfo;
  beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
  beginInfo.pNext = <span class="hljs-literal">nullptr</span>;
  beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
  beginInfo.pInheritanceInfo = <span class="hljs-literal">nullptr</span>;
  vkBeginCommandBuffer(commandBuffer, &amp;beginInfo);</code></pre><p>

Then, for each instance in the scene, we generate the bottom-level acceleration structure:
</p><pre class="listing tilde"><code>  <span class="hljs-comment">// For each geometric object, we compute the corresponding bottom-level acceleration structure</span>
  <span class="hljs-comment">// (BLAS)</span>
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;accelerationstructure&gt; blas(m_geometryInstances.size());
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::pair&lt;vkaccelerationstructurenv, glm::mat4x4=""&gt;&gt; instances;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; m_geometryInstances.size(); i++)
  {
    blas[i] = createBottomLevelAS(
        commandBuffer, {
                           {m_geometryInstances[i].vertexBuffer, m_geometryInstances[i].vertexCount,
                            m_geometryInstances[i].vertexOffset, m_geometryInstances[i].indexBuffer,
                            m_geometryInstances[i].indexCount, m_geometryInstances[i].indexOffset},
                       });
    instances.push_back({blas[i].structure, m_geometryInstances[i].transform});
  }</code></pre><p>

The top-level AS is then created using the above instance definitions.
</p><pre class="listing tilde"><code>  <span class="hljs-comment">// Create the top-level AS from the previously computed BLAS</span>
  createTopLevelAS(commandBuffer, instances, VK_FALSE);</code></pre><p>

We finalize the build by submitting the command buffer, waiting for it to complete, and freeing our one-time
command buffer. 
</p><pre class="listing tilde"><code><span class="hljs-comment">// End the command buffer and submit it</span>
  vkEndCommandBuffer(commandBuffer);

  VkSubmitInfo submitInfo;
  submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
  submitInfo.pNext = <span class="hljs-literal">nullptr</span>;
  submitInfo.waitSemaphoreCount = <span class="hljs-number">0</span>;
  submitInfo.pWaitSemaphores = <span class="hljs-literal">nullptr</span>;
  submitInfo.pWaitDstStageMask = <span class="hljs-literal">nullptr</span>;
  submitInfo.commandBufferCount = <span class="hljs-number">1</span>;
  submitInfo.pCommandBuffers = &amp;commandBuffer;
  submitInfo.signalSemaphoreCount = <span class="hljs-number">0</span>;
  submitInfo.pSignalSemaphores = <span class="hljs-literal">nullptr</span>;

  vkQueueSubmit(VkCtx.getQueue(), <span class="hljs-number">1</span>, &amp;submitInfo, VK_NULL_HANDLE);
  vkQueueWaitIdle(VkCtx.getQueue());
  vkFreeCommandBuffers(VkCtx.getDevice(), VkCtx.getCommandPool()[VkCtx.getFrameIndex()], <span class="hljs-number">1</span>,
                       &amp;commandBuffer);
}</code></pre>
<a class="target" name="main">&nbsp;</a><h2>main</h2>
<p>

In the <code>main</code> function, we can now add the creation of the geometry instances and acceleration structures right after initializing the
ray tracing extension:
</p><pre class="listing tilde"><code>// <span class="hljs-comment">#VKRT</span>
helloVulkan.initRayTracing();
helloVulkan.createGeometryInstances();
helloVulkan.createAccelerationStructures();</code></pre>
<a class="target" name="raytracingoutputbuffer">&nbsp;</a><h1>Ray Tracing output buffer</h1>
<p>


Before going further into the construction of the other objects specific to the ray tracing extension, we need to allocate a
buffer that will hold the results of the ray tracing process: unlike rasterization, ray tracing cannot directly write into a 
render target. The output is a simple Vulkan image, so we add the following in the class definition:
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createRaytracingOutput</span><span class="hljs-params">()</span></span>;
VkImage m_rtOutputImage = VK_NULL_HANDLE;
VkDeviceMemory m_rtOutputMemory = VK_NULL_HANDLE;
VkImageView m_rtOutputImageView = VK_NULL_HANDLE;</code></pre><p>

The implementation is a straightforward Vulkan allocation of a 2D image the size of the framebuffer:
</p><pre class="listing tilde"><code><span class="hljs-comment">//--------------------------------------------------------------------------------------------------</span>
<span class="hljs-comment">// Create the ray tracing output buffer, where the RT shaders will write and which will be copied to</span>
<span class="hljs-comment">// the render target</span>
<span class="hljs-comment">// #VKRT</span>
<span class="hljs-keyword">void</span> HelloVulkan::createRaytracingOutput()
{
  VkImageCreateInfo imageCreateInfo;
  imageCreateInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
  imageCreateInfo.pNext = <span class="hljs-literal">nullptr</span>;
  imageCreateInfo.flags = <span class="hljs-number">0</span>;
  imageCreateInfo.imageType = VK_IMAGE_TYPE_2D;
  imageCreateInfo.format = VkCtx.getSurfaceFormat();
  imageCreateInfo.extent.width = m_framebufferSize.width;
  imageCreateInfo.extent.height = m_framebufferSize.height;
  imageCreateInfo.extent.depth = <span class="hljs-number">1</span>;
  imageCreateInfo.mipLevels = <span class="hljs-number">1</span>;
  imageCreateInfo.arrayLayers = <span class="hljs-number">1</span>;
  imageCreateInfo.samples = VK_SAMPLE_COUNT_1_BIT;
  imageCreateInfo.tiling = VK_IMAGE_TILING_OPTIMAL;
  imageCreateInfo.usage = VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT;
  imageCreateInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
  imageCreateInfo.queueFamilyIndexCount = <span class="hljs-number">0</span>;
  imageCreateInfo.pQueueFamilyIndices = <span class="hljs-literal">nullptr</span>;
  imageCreateInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;

  VkResult code = vkCreateImage(VkCtx.getDevice(), &amp;imageCreateInfo, <span class="hljs-literal">nullptr</span>, &amp;m_rtOutputImage);

  <span class="hljs-keyword">if</span> (code != VK_SUCCESS)
  {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::logic_error(<span class="hljs-string">"rt vkCreateImage failed"</span>);
  }

  VkMemoryRequirements memoryRequirements;
  vkGetImageMemoryRequirements(VkCtx.getDevice(), m_rtOutputImage, &amp;memoryRequirements);

  VkMemoryAllocateInfo memoryAllocateInfo;
  memoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
  memoryAllocateInfo.pNext = <span class="hljs-literal">nullptr</span>;
  memoryAllocateInfo.allocationSize = memoryRequirements.size;
  memoryAllocateInfo.memoryTypeIndex =
      nv_helpers_vk::findMemoryType(VkCtx.getPhysicalDevice(), memoryRequirements.memoryTypeBits,
                                    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);

  code = vkAllocateMemory(VkCtx.getDevice(), &amp;memoryAllocateInfo, <span class="hljs-literal">nullptr</span>, &amp;m_rtOutputMemory);

  <span class="hljs-keyword">if</span> (code != VK_SUCCESS)
  {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::logic_error(<span class="hljs-string">"rt vkAllocateMemory failed"</span>);
  }

  code = vkBindImageMemory(VkCtx.getDevice(), m_rtOutputImage, m_rtOutputMemory, <span class="hljs-number">0</span>);

  <span class="hljs-keyword">if</span> (code != VK_SUCCESS)
  {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::logic_error(<span class="hljs-string">"rt vkBindImageMemory failed"</span>);
  }

  VkImageViewCreateInfo imageViewCreateInfo;
  imageViewCreateInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
  imageViewCreateInfo.pNext = <span class="hljs-literal">nullptr</span>;
  imageViewCreateInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
  imageViewCreateInfo.format = VkCtx.getSurfaceFormat();
  imageViewCreateInfo.subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>};
  imageViewCreateInfo.image = m_rtOutputImage;
  imageViewCreateInfo.flags = <span class="hljs-number">0</span>;
  imageViewCreateInfo.components = {VK_COMPONENT_SWIZZLE_R, VK_COMPONENT_SWIZZLE_G,
                                    VK_COMPONENT_SWIZZLE_B, VK_COMPONENT_SWIZZLE_A};

  code = vkCreateImageView(VkCtx.getDevice(), &amp;imageViewCreateInfo, <span class="hljs-literal">nullptr</span>, &amp;m_rtOutputImageView);
  <span class="hljs-keyword">if</span> (code != VK_SUCCESS)
  {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::logic_error(<span class="hljs-string">"rt vkCreateImageView failed"</span>);
  }
}</code></pre>
<a class="target" name="main">&nbsp;</a><h2>main</h2>
<p>

In the <code>main</code> function, add the creation of the ray tracing output image after the building of the acceleration structures:
</p><pre class="listing tilde"><code><span class="hljs-selector-tag">helloVulkan</span><span class="hljs-selector-class">.createRaytracingOutput</span>();</code></pre>
<a class="target" name="raytracingdescriptorset">&nbsp;</a><h1>Ray Tracing Descriptor Set</h1>
<p>


The ray tracing shaders, like the rasterization shaders, use external 
resources grouped into a descriptor set. A key difference,
however, is that in a scene requiring several types of shaders, the 
rasterization would allow each set of shaders to have their own
descriptor set(s). For example, objects with different materials may 
each have a descriptor set containing the handles of the textures
it needs. This is easily done since for a given material, we would 
create its corresponding rasterization pipeline and use that pipeline 
to render all the objects with that material. On the contrary, with ray 
tracing it is not possible to know in advance which objects will
be hit by a ray, so any shader may be invoked at any time. The Vulkan 
ray tracing extension then uses a single descriptor set containing
all the resources necessary to render the scene: for example, it would 
contain all the textures for all the materials. 

</p><p>

In the class definition, we will add a method to create that descriptor 
set, as well as thestorage for the descriptor pool, layout and set 
itself.
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createRaytracingDescriptorSet</span><span class="hljs-params">()</span></span>;
VkDescriptorPool m_rtDescriptorPool;
VkDescriptorSetLayout m_rtDescriptorSetLayout;
VkDescriptorSet m_rtDescriptorSet;</code></pre><p>

For simplicity we will use a helper class for generating the descriptor 
pool, layout and set, by adding this include after the other includes
of the source file:
</p><pre class="listing tilde"><code><span class="hljs-meta">#</span><span class="bash">include <span class="hljs-string">"nv_helpers_vk/DescriptorSetGenerator.h"</span></span></code></pre><p>




The implementation of the descriptor set first makes sure the geometry data has finished uploading on the
GPU using a barrier:
</p><pre class="listing tilde"><code><span class="hljs-comment">//--------------------------------------------------------------------------------------------------</span>
<span class="hljs-comment">// Create the descriptor set used by the ray tracing shaders: note that all shaders will access the</span>
<span class="hljs-comment">// same descriptor set, and therefore the set needs to contain all the resources used by the</span>
<span class="hljs-comment">// shaders. For example, it will contain all the textures used in the scene.</span>
<span class="hljs-keyword">void</span> HelloVulkan::createRaytracingDescriptorSet()
{
  <span class="hljs-comment">// We will bind the vertex and index buffers, so we first add a barrier on those buffers to make</span>
  <span class="hljs-comment">// sure their data is actually present on the GPU</span>
  VkBufferMemoryBarrier bmb = {};
  bmb.sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER;
  bmb.pNext = <span class="hljs-literal">nullptr</span>;
  bmb.srcAccessMask = <span class="hljs-number">0</span>;
  bmb.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
  bmb.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
  bmb.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
  bmb.offset = <span class="hljs-number">0</span>;
  bmb.size = VK_WHOLE_SIZE;

  VkCommandBuffer commandBuffer = VkCtx.beginSingleTimeCommands();

  bmb.buffer = m_vertexBuffer;
  vkCmdPipelineBarrier(commandBuffer, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
                       VK_PIPELINE_STAGE_ALL_COMMANDS_BIT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">1</span>, &amp;bmb, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);
  bmb.buffer = m_indexBuffer;
  vkCmdPipelineBarrier(commandBuffer, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
                       VK_PIPELINE_STAGE_ALL_COMMANDS_BIT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">1</span>, &amp;bmb, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);
  VkCtx.endSingleTimeCommands(commandBuffer);</code></pre><p>

The descriptor set generation helper first requires the definition of all the bindings: the binding point as defined in the <code>layout(binding = xx)</code>
 of the shaders,
the number of descriptor for that binding location, the descriptor type 
and in which shader the descriptor(s) would be used. Our ray tracing 
shaders will,
arbitrarily, use location 0 for the top-level acceleration structure, 1 
for the ray tracing output, 2 for the camera information, 3-4 for the 
geometry data (that will be used for shading), 
5 for the material information, and 6 for the material textures. 
</p><pre class="listing tilde"><code>  <span class="hljs-comment">// Use the descriptor set generator helper to facilitate the creation of the descriptor pool,</span>
  <span class="hljs-comment">// layout, and set</span>
  nv_helpers_vk::DescriptorSetGenerator dsg;

  <span class="hljs-comment">// Add the bindings to the resources</span>
  <span class="hljs-comment">// Top-level acceleration structure, usable by the ray generation </span>
  dsg.AddBinding(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV,
                 VK_SHADER_STAGE_RAYGEN_BIT_NV);
  <span class="hljs-comment">// Ray Tracing output</span>
  dsg.AddBinding(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, VK_SHADER_STAGE_RAYGEN_BIT_NV);
  <span class="hljs-comment">// Camera information</span>
  dsg.AddBinding(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_SHADER_STAGE_RAYGEN_BIT_NV);
  <span class="hljs-comment">// Scene data</span>
  <span class="hljs-comment">// Vertex buffer</span>
  dsg.AddBinding(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV);
  <span class="hljs-comment">// Index buffer</span>
  dsg.AddBinding(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV);
  <span class="hljs-comment">// Material buffer</span>
  dsg.AddBinding(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV);
  <span class="hljs-comment">// Textures</span>
  dsg.AddBinding(<span class="hljs-number">6</span>, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(m_textureSampler.size()),
                 VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV);</code></pre><p>

From this information we can create the descriptor pool, layout and a descriptor set. Internally, those
methods use the <code>vkCreateDescriptorPool</code>, <code>vkCreateDescriptorSetLayout</code> and <code>vkAllocateDescriptorSets</code> calls.
</p><pre class="listing tilde"><code>  <span class="hljs-comment">// Create the descriptor pool and layout</span>
  m_rtDescriptorPool = dsg.GeneratePool(VkCtx.getDevice());
  m_rtDescriptorSetLayout = dsg.GenerateLayout(VkCtx.getDevice());

  <span class="hljs-comment">// Generate the descriptor set</span>
  m_rtDescriptorSet =
      dsg.GenerateSet(VkCtx.getDevice(), m_rtDescriptorPool, m_rtDescriptorSetLayout);</code></pre><p>

Once the descriptor set has been allocated, we fill it with the actual descriptors using the <code>Bind</code> method, which takes
a <code>VkDescriptor*Info</code> (or a <code>VkWriteDescriptorSetAccelerationStructNV</code>
 for acceleration structures) defining the resource being bound to each 
location. Here, we bind the top-level acceleration structure:
</p><pre class="listing tilde"><code>  <span class="hljs-comment">// Bind the actual resources into the descriptor set</span>
  <span class="hljs-comment">// Top-level acceleration structure</span>
  VkWriteDescriptorSetAccelerationStructureNV descriptorAccelerationStructureInfo;
  descriptorAccelerationStructureInfo.sType =
      VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV;
  descriptorAccelerationStructureInfo.pNext = <span class="hljs-literal">nullptr</span>;
  descriptorAccelerationStructureInfo.accelerationStructureCount = <span class="hljs-number">1</span>;
  descriptorAccelerationStructureInfo.pAccelerationStructures = &amp;m_topLevelAS.structure;

  dsg.Bind(m_rtDescriptorSet, <span class="hljs-number">0</span>, {descriptorAccelerationStructureInfo});</code></pre><p>

The other resources follow the same pattern, so that the output buffer, 
camera matrices, geometry data, material definition and textures are
bound in the descriptor set. 
</p><pre class="listing tilde"><code>  <span class="hljs-comment">// Output buffer</span>
  VkDescriptorImageInfo descriptorOutputImageInfo;
  descriptorOutputImageInfo.sampler = nullptr;
  descriptorOutputImageInfo.imageView = m_rtOutputImageView;
  descriptorOutputImageInfo.imageLayout = VK_IMAGE_LAYOUT_GENERAL;

  dsg.Bind(m_rtDescriptorSet, <span class="hljs-number">1</span>, {descriptorOutputImageInfo});

  <span class="hljs-comment">// Camera matrices</span>
  VkDescriptorBufferInfo camInfo = {};
  camInfo.<span class="hljs-keyword">buffer</span> = m_uniformBuffer;
  camInfo.<span class="hljs-keyword">offset</span> = <span class="hljs-number">0</span>;
  camInfo.range = sizeof(UniformBufferObject);

  dsg.Bind(m_rtDescriptorSet, <span class="hljs-number">2</span>, {camInfo});

  <span class="hljs-comment">// Vertex buffer</span>
  VkDescriptorBufferInfo vertexInfo = {};
  vertexInfo.<span class="hljs-keyword">buffer</span> = m_vertexBuffer;
  vertexInfo.<span class="hljs-keyword">offset</span> = <span class="hljs-number">0</span>;
  vertexInfo.range = VK_WHOLE_SIZE;

  dsg.Bind(m_rtDescriptorSet, <span class="hljs-number">3</span>, {vertexInfo});

  <span class="hljs-comment">// Index buffer</span>
  VkDescriptorBufferInfo indexInfo = {};
  indexInfo.<span class="hljs-keyword">buffer</span> = m_indexBuffer;
  indexInfo.<span class="hljs-keyword">offset</span> = <span class="hljs-number">0</span>;
  indexInfo.range = VK_WHOLE_SIZE;

  dsg.Bind(m_rtDescriptorSet, <span class="hljs-number">4</span>, {indexInfo});

  <span class="hljs-comment">// Material buffer</span>
  VkDescriptorBufferInfo materialInfo = {};
  materialInfo.<span class="hljs-keyword">buffer</span> = m_matColorBuffer;
  materialInfo.<span class="hljs-keyword">offset</span> = <span class="hljs-number">0</span>;
  materialInfo.range = VK_WHOLE_SIZE;
  dsg.Bind(m_rtDescriptorSet, <span class="hljs-number">5</span>, {materialInfo});

  <span class="hljs-comment">// Textures</span>
  std::vector&lt;vkdescriptorimageinfo&gt; imageInfos;
  <span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">0</span>; i &lt; m_textureSampler.size(); ++i)
  {
    VkDescriptorImageInfo imageInfo = {};
    imageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo.imageView = m_textureImageView[i];
    imageInfo.sampler = m_textureSampler[i];
    imageInfos.push_back(imageInfo);
  }
  <span class="hljs-keyword">if</span> (!m_textureSampler.empty())
  {
    dsg.Bind(m_rtDescriptorSet, <span class="hljs-number">6</span>, imageInfos);
  }</code></pre><p>

The actual binding is done by calling <code>UpdateSetContents</code>, which will invoke <code>vkUpdateDescriptorSets</code> to write the 
binding data into the descriptor set:
</p><pre class="listing tilde"><code>  <span class="hljs-comment">// Copy the bound resource handles into the descriptor set</span>
  dsg.UpdateSetContents(VkCtx.getDevice(), m_rtDescriptorSet);
}</code></pre>
<a class="target" name="main">&nbsp;</a><h2>main</h2>
<p>

In the <code>main</code> function, add the creation of the descriptor set after the other ray tracing calls:
</p><pre class="listing tilde"><code><span class="hljs-selector-tag">helloVulkan</span><span class="hljs-selector-class">.createRaytracingDescriptorSet</span>();</code></pre>
<a class="target" name="raytracingpipeline">&nbsp;</a><h1>Ray Tracing Pipeline</h1>
<p>


When creating rasterization shaders with Vulkan, the application 
compiles them into executable shaders, which are bound to the 
rasterization pipeline. All objects rendered using this pipeline will 
use those shaders. To render an image with several types of 
shaders, the rasterization pipeline needs to be set to use each before 
calling the draw commands.

</p><p>

In a ray tracing context, a ray traced to the scene can hit any object 
and thus trigger the execution of any shader. Instead of using one 
shader
executable at a time, we now need to have all shaders available at once.
 The pipeline then contains all the shader required to render the scene,
 and information on how to execute it. To be able to raytrace some 
geometry, the Vulkan ray tracing extension requires at least 3 shader 
programs: 

</p><p>

</p><ul>
<li class="asterisk">The ray generation program, that will be the 
starting point of the ray tracing, and called for each pixel: it will 
typically initialize a ray
  starting at the location of the camera, in a direction given by 
evaluating the camera lens model at the pixel location. 
  It will then invoke <code>traceNV()</code>, that will shoot the ray in the scene. Other shaders below will process further events, and return
  their result to the ray generation shader through the ray payload. 
</li>
<li class="asterisk">The miss shader is executed when a ray does not 
intersect any geometry. It can typically sample an environment map, or 
return a simple color 
  through the ray payload.
</li>
<li class="asterisk">The closest hit shader is called upon hitting a the
 geometric instance closest to the starting point of the ray. This 
shader can for example 
  perform lighting calculations, and return the results through the ray 
payload. There can be as many closest hit shaders as needed, in the same
  spirit as a rasterization-based application has multiple pixel shaders
 depending on the objects.</li></ul>

<p></p><p>

Two more shader types can optionally be used:

</p><p>

</p><ul>
<li class="asterisk">The intersection shader, which allows intersecting 
user-defined geometry. For example, this can be particularly useful when
 intersecting
  procedural geometry or subdivision surfaces without tesselating them 
beforehand. 
  Using this shader requires modifying how the acceleration structures 
are built, and is beyond the scope of this tutorial.
  We will instead rely on the built-in triangle intersection shader 
provided by the extension, which returns 2 floating-point
  values representing the barycentric coordinates <code>(u,v)</code> of the hit point inside the triangle. For a triangle made of vertices 
  <code>v0</code>, <code>v1</code>, <code>v2</code>, the barycentric coordinates define the weights of the vertices as follows:</li></ul>

<p></p><p>

<svg class="diagram" xmlns="http://www.w3.org/2000/svg" version="1.1" height="144" width="168" style="margin:0 auto 0 auto;"><g transform="translate(8,16 )">
<path d="M 40,96 L 136,96 " style="fill:none;"></path>
<path d="M 88,0 L 136,96 " style="fill:none;"></path>
<path d="M 40,96 L 88,0 " style="fill:none;"></path>
<g transform="translate(0,0)"><text text-anchor="middle" x="104" y="4">u</text><text text-anchor="middle" x="88" y="36">v</text><text text-anchor="middle" x="96" y="36">1</text><text text-anchor="middle" x="8" y="84">1</text><text text-anchor="middle" x="16" y="84">-</text><text text-anchor="middle" x="24" y="84">u</text><text text-anchor="middle" x="32" y="84">-</text><text text-anchor="middle" x="40" y="84">v</text><text text-anchor="middle" x="64" y="84">v</text><text text-anchor="middle" x="72" y="84">0</text><text text-anchor="middle" x="104" y="84">v</text><text text-anchor="middle" x="112" y="84">2</text><text text-anchor="middle" x="144" y="84">v</text></g></g></svg>

</p><p>

</p><ul>
<li class="asterisk">The any hit shader is executed on each potential 
intersection: when searching for the hit point closest to the ray 
origin, several candidates
  may be found on the way. The any hit shader can typically be used to 
efficiently implement alpha-testing. If the alpha test fails, the ray 
  traversal can continue without having to call <code>traceNV()</code> again. The built-in any hit shader is simply a pass-trough returning the intersection
  to the traversal engine that will determine which potential intersection is the closest. 

<p></p><p>

  </p><center><div class="image" style=""><a href="https://developer.nvidia.com/sites/default/files/pictures/2019/vulkan_raytracing/ShaderPipeline.svg" target="_blank"><img class="markdeep" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/ShaderPipeline.svg"></a><div class="imagecaption"><a class="target" name="figure_step">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;2:</b> The Ray Tracing Pipeline</div></div></center></li></ul>

<p></p><p>

In this tutorial we will create a pipeline containing only the 3 
mandatory shader programs: a single ray generation, single miss and a 
single closest
hit. This is done by first compiling each GLSL shader program into 
SPIR-V. The SPIR-V shaders will be linked 
together within the raytracing pipeline, which will be able to route the
 intersection calculations to the right hit shaders. 

</p><p>

To be able to focus on the pipeline generation, we provide simplistic shaders:

</p><p>

</p><div class="admonition note"><div class="admonition-title"> Shaders (<a href="https://developer.nvidia.com/rtx/raytracing/vkrt_helpers/files/shaders.zip">Download</a>)</div>

<p></p><p>

    Download the shaders and extract the content to the project folder.</p></div>

<p></p><p>

The <code>shaders</code> folder now contains 3 more files:

</p><p>

</p><ul>
<li class="asterisk"><code>rayGen.rgen</code> contains the ray generation program. It also declares its 
  access to the ray tracing output buffer <code>image</code>, and the ray tracing acceleration structure <code>topLevelAS</code>, 
  bound as a <code>accelerationStructureNV</code>. For now this shader program simply writes a constant color in the ray tracing output buffer. 
</li>
<li class="asterisk"><code>miss.rmiss</code> defines the Miss shader. This shader will be executed when no geometry is hit, and will
  write a constant color in the ray payload <code>rayPayloadInNV</code>,
 which is provided automatically. Since our current ray generation 
program does not trace any ray for now, this shader will not be called.
</li>
<li class="asterisk"><code>closestHit.rchit</code> contains a very simple closest hit shader. It will be executed upon
  hitting the geometry (our triangle). As the miss shader, it takes the ray payload <code>rayPayloadInNV</code>. It also has a second
  input defining the intersection attributes <code>hitAttributeNV</code> as provided by the intersection shader, ie. the barycentric coordinates. This shader simply 
  writes a constant color to the payload.</li></ul>

<p></p><p>

In order to use the GLSL compiler for our new shaders, we need to modify the properties of the project to use the <code>GLSLValidateVS.props</code>
 we just extracted from the archive instead of the 
default ones. For this, go to the 'Property Manager', right-click on the
 project name, choose 'Add existing property sheet' and choose <code>GLSLValidateVS.props</code>. 

</p><p>

Add the shader files in the <code>shaders</code> filter of the Visual Studio project. For each, make sure that their properties page says the <code>Item Type</code> is <code>GLSL Validator</code>. All the shader files should compile,
and the resulting SPIR-V files are stored in the <code>shaders</code> folder alongside the GLSL files. 

</p><p>

In the header file, add the definition of the ray tracing pipeline building method, and the storage members of the pipeline:
</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createRaytracingPipeline</span><span class="hljs-params">()</span></span>;
VkPipelineLayout m_rtPipelineLayout = VK_NULL_HANDLE;
VkPipeline m_rtPipeline = VK_NULL_HANDLE;

<span class="hljs-keyword">uint32_t</span> m_rayGenIndex;
<span class="hljs-keyword">uint32_t</span> m_hitGroupIndex;
<span class="hljs-keyword">uint32_t</span> m_missIndex;</code></pre><p>

After the other includes of the source file, add the include for the ray tracing pipeline generation helper:
</p><pre class="listing tilde"><code><span class="hljs-meta">#</span><span class="bash">include <span class="hljs-string">"nv_helpers_vk/RaytracingPipelineGenerator.h"</span></span></code></pre><p>

The implementation of the ray tracing pipeline generation starts by 
adding the ray generation and miss shader stages, although this could be
 done in arbitrary order.
When setting up the stages of the pipeline, each addition call returns 
the index of the stage in the pipeline, which will be later used to 
associate the pipeline 
stages to actual geometries and provide entry points for the ray tracing
 process.
</p><pre class="listing tilde"><code><span class="hljs-comment">//--------------------------------------------------------------------------------------------------</span>
<span class="hljs-comment">// Create the ray tracing pipeline, containing the handles and data for each ray tracing shader</span>
<span class="hljs-comment">// For each shader or hit group we retain its index, so that they can be bound to the geometry in</span>
<span class="hljs-comment">// the shader binding table.</span>
<span class="hljs-keyword">void</span> HelloVulkan::createRaytracingPipeline()
{

  nv_helpers_vk::RayTracingPipelineGenerator pipelineGen;
  <span class="hljs-comment">// We use only one ray generation, that will implement the camera model</span>
  m_rayGenIndex =
      pipelineGen.AddRayGenShaderStage(VkCtx.createShaderModule(readFile(<span class="hljs-string">"shaders/raygen.spv"</span>)));
  <span class="hljs-comment">// The first miss shader is used to look-up the environment in case the rays from the camera miss</span>
  <span class="hljs-comment">// the geometry</span>
  m_missIndex =
      pipelineGen.AddMissShaderStage(VkCtx.createShaderModule(readFile(<span class="hljs-string">"shaders/miss.spv"</span>)));</code></pre><p>

All the shaders related to the intersection of a given object type are 
grouped into a hit group. At most, a hit group can contain
an intersection shader, an any hit shader, and a closest hit shader. For
 simplicity, we use the built-in intersection and any-hit shaders,
which leaves our hit group with only one entry, the closest hit shader:
</p><pre class="listing tilde"><code>  <span class="hljs-comment">// The first hit group defines the shaders invoked when a ray shot from the camera hit the</span>
  <span class="hljs-comment">// geometry. In this case we only specify the closest hit shader, and rely on the build-in</span>
  <span class="hljs-comment">// triangle intersection and pass-through any-hit shader. However, explicit intersection and</span>
  <span class="hljs-comment">// any hit shaders could be added as well.</span>
  m_hitGroupIndex = pipelineGen.StartHitGroup();

  pipelineGen.AddHitShaderStage(VkCtx.createShaderModule(readFile(<span class="hljs-string">"shaders/closesthit.spv"</span>)),
                                VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV);
  pipelineGen.EndHitGroup();</code></pre><p>

From those 3 shaders and an indication of the maximum possible recursion level we want to use, we can now generate the pipeline,
 which internally calls <code>vkCreatePipelineLayout</code> and <code>vkCreateRaytracingPipelinesNV</code>:
</p><pre class="listing tilde"><code>  <span class="hljs-comment">// The ray tracing process now can only shoot rays from the camera, hence a recursion level of 2. </span>
  <span class="hljs-comment">// This number should be kept as low</span>
  <span class="hljs-comment">// as possible for performance reasons. Even recursive ray tracing should be flattened into a loop</span>
  <span class="hljs-comment">// in the ray generation to avoid deep recursion.</span>
  pipelineGen.SetMaxRecursionDepth(<span class="hljs-number">1</span>);

  <span class="hljs-comment">// Generate the pipeline</span>
  pipelineGen.Generate(VkCtx.getDevice(), m_rtDescriptorSetLayout, &amp;m_rtPipeline,
                       &amp;m_rtPipelineLayout);
}</code></pre>
<a class="target" name="main">&nbsp;</a><h2>main</h2>
<p>

In the <code>main</code> function, add the pipeline construction after the other ray tracing calls:
</p><pre class="listing tilde"><code><span class="hljs-selector-tag">helloVulkan</span><span class="hljs-selector-class">.createRaytracingPipeline</span>();</code></pre>
<a class="target" name="shaderbindingtable">&nbsp;</a><h1>Shader Binding Table</h1>
<p>


The Shader Binding Table is where all programs and TLAS are bind together to know which program to execute. 

</p><p>

There is one ray generation, at least one miss, and a number of hit groups. There should be <em class="asterisk">n</em> 
 hit group entries, up to the maximum index passed to the instance description parameter <code>instanceOffset</code>.

</p><p>

In a typical rasterization setup, a current shader and its associated resources are bound prior to drawing the corresponding
objects, then another shader and resource set can be bound for some other objects, and so on. Since ray tracing can hit any
surface of the scene at any time, it is impossible to know in advance which shaders need to be bound. Therefore, the Shader
Binding Table (SBT) is an array of SBT entries holding information on the location of shaders and their resources for each
object.

</p>
<a class="target" name="sbtentry">&nbsp;</a><h2>SBT Entry</h2>
<p>

A SBT entry consists of a header and data section. The header stores a 
shader identifier, while the data section provides pushconstant data. 

</p><p>

In the header file add the following include
</p><pre class="listing tilde"><code><span class="hljs-meta">#</span><span class="bash">include <span class="hljs-string">"nv_helpers_vk/ShaderBindingTableGenerator.h"</span></span></code></pre><p>

This file contains our SBT <a href="https://developer.nvidia.com/rtx/raytracing/vulkan_tutorial_helpers.md.htm">helper</a> that eases the SBT creation process and enforces consistency between
the SBT layout and the later ray tracing calls. Internally the <code>Add*</code> methods collect the names of the shader programs associated with the pointers of 
their input resources in GPU memory. The <code>Generate</code> call maps the input buffer and, for each collected entry, sets the corresponding shader
identifier using <code>vkGetRayTracingShaderGroupHandlesNV</code> and copies its resource pointers afterwards. The helper first copies 
the ray generation programs, then the miss programs, and finally the hit groups. 

</p><p>

And add the following declarations:

</p><pre class="listing tilde"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createShaderBindingTable</span><span class="hljs-params">()</span></span>;
nv_helpers_vk::ShaderBindingTableGenerator m_sbtGen;
VkBuffer m_shaderBindingTableBuffer;
VkDeviceMemory m_shaderBindingTableMem;</code></pre><p>

The Shader Binding Table (SBT) is the cornerstone of the ray tracing 
setup: it links the geometry instances to their
corresponding hit groups, and binds the pushconstant values to the ray 
tracing shader programs. 
In this tutorial, we have a scene containing a single instance. The 
Shader Binding Table would then have 3 entries: one for the ray
 generation program, one for
the miss program, and one for the hit group. None of them are using 
pushconstant values, therefore the SBT is then laid out as 
follows:

</p><p>

<svg class="diagram" xmlns="http://www.w3.org/2000/svg" version="1.1" height="192" width="136" style="margin:0 auto 0 auto;"><g transform="translate(8,16 )">
<path d="M 0,0 L 0,144 " style="fill:none;"></path>
<path d="M 120,0 L 120,144 " style="fill:none;"></path>
<path d="M 0,0 L 120,0 " style="fill:none;"></path>
<path d="M 0,48 L 120,48 " style="fill:none;"></path>
<path d="M 0,96 L 120,96 " style="fill:none;"></path>
<path d="M 0,144 L 120,144 " style="fill:none;"></path>
<g transform="translate(0,0)"><text text-anchor="middle" x="16" y="20">R</text><text text-anchor="middle" x="24" y="20">a</text><text text-anchor="middle" x="32" y="20">y</text><text text-anchor="middle" x="40" y="20">G</text><text text-anchor="middle" x="48" y="20">e</text><text text-anchor="middle" x="56" y="20">n</text><text text-anchor="middle" x="16" y="36">I</text><text text-anchor="middle" x="24" y="36">d</text><text text-anchor="middle" x="32" y="36">e</text><text text-anchor="middle" x="40" y="36">n</text><text text-anchor="middle" x="48" y="36">t</text><text text-anchor="middle" x="56" y="36">i</text><text text-anchor="middle" x="64" y="36">f</text><text text-anchor="middle" x="72" y="36">i</text><text text-anchor="middle" x="80" y="36">e</text><text text-anchor="middle" x="88" y="36">r</text><text text-anchor="middle" x="16" y="68">M</text><text text-anchor="middle" x="24" y="68">i</text><text text-anchor="middle" x="32" y="68">s</text><text text-anchor="middle" x="40" y="68">s</text><text text-anchor="middle" x="16" y="84">I</text><text text-anchor="middle" x="24" y="84">d</text><text text-anchor="middle" x="32" y="84">e</text><text text-anchor="middle" x="40" y="84">n</text><text text-anchor="middle" x="48" y="84">t</text><text text-anchor="middle" x="56" y="84">i</text><text text-anchor="middle" x="64" y="84">f</text><text text-anchor="middle" x="72" y="84">i</text><text text-anchor="middle" x="80" y="84">e</text><text text-anchor="middle" x="88" y="84">r</text><text text-anchor="middle" x="16" y="116">H</text><text text-anchor="middle" x="24" y="116">i</text><text text-anchor="middle" x="32" y="116">t</text><text text-anchor="middle" x="40" y="116">G</text><text text-anchor="middle" x="48" y="116">r</text><text text-anchor="middle" x="56" y="116">o</text><text text-anchor="middle" x="64" y="116">u</text><text text-anchor="middle" x="72" y="116">p</text><text text-anchor="middle" x="16" y="132">I</text><text text-anchor="middle" x="24" y="132">d</text><text text-anchor="middle" x="32" y="132">e</text><text text-anchor="middle" x="40" y="132">n</text><text text-anchor="middle" x="48" y="132">t</text><text text-anchor="middle" x="56" y="132">i</text><text text-anchor="middle" x="64" y="132">f</text><text text-anchor="middle" x="72" y="132">i</text><text text-anchor="middle" x="80" y="132">e</text><text text-anchor="middle" x="88" y="132">r</text></g></g></svg>

</p><p>

When starting the ray tracing process, the identifier of the ray 
generation program will be used to execute its entry point for each
pixel. When the ray generation program shoots a ray, the descriptor set 
will be used to find the location of the top-level acceleration 
structure in GPU memory and trigger the tracing itself. The
ray may miss all geometry, in which case the SBT will be used to find 
the miss shader identifier and execute the corresponding code. If the 
ray  
hits the geometry, the hit group identifier will be used to find the 
shaders associated to the hit group: intersection, any hit and 
closest hit. In order, those shaders will be executed, and the result 
sent to the ray generation shader. The ray generation shader can then
access the ray tracing output buffer from the descriptor set, and write 
its result. 

</p><p>

If the scene contains several objects, with different hit groups, the 
SBT will contain all the hit groups and their pushconstant values. As an
 example,
we could have 3 objects, each accessing some camera data in the 
descriptor set. Objects 0 and 1 would have each their own texture index,
 while Object 2 
would not have one. The SBT would then have this structure:

</p><p>

<svg class="diagram" xmlns="http://www.w3.org/2000/svg" version="1.1" height="432" width="136" style="margin:0 auto 0 auto;"><g transform="translate(8,16 )">
<path d="M 0,0 L 0,384 " style="fill:none;"></path>
<path d="M 120,0 L 120,384 " style="fill:none;"></path>
<path d="M 0,0 L 120,0 " style="fill:none;"></path>
<path d="M 0,48 L 120,48 " style="fill:none;"></path>
<path d="M 0,96 L 120,96 " style="fill:none;"></path>
<path d="M 0,144 L 120,144 " style="fill:none;"></path>
<path d="M 0,192 L 120,192 " style="fill:none;"></path>
<path d="M 0,240 L 120,240 " style="fill:none;"></path>
<path d="M 0,288 L 120,288 " style="fill:none;"></path>
<path d="M 0,336 L 120,336 " style="fill:none;"></path>
<path d="M 0,384 L 120,384 " style="fill:none;"></path>
<g transform="translate(0,0)"><text text-anchor="middle" x="16" y="20">R</text><text text-anchor="middle" x="24" y="20">a</text><text text-anchor="middle" x="32" y="20">y</text><text text-anchor="middle" x="40" y="20">G</text><text text-anchor="middle" x="48" y="20">e</text><text text-anchor="middle" x="56" y="20">n</text><text text-anchor="middle" x="16" y="36">I</text><text text-anchor="middle" x="24" y="36">d</text><text text-anchor="middle" x="32" y="36">e</text><text text-anchor="middle" x="40" y="36">n</text><text text-anchor="middle" x="48" y="36">t</text><text text-anchor="middle" x="56" y="36">i</text><text text-anchor="middle" x="64" y="36">f</text><text text-anchor="middle" x="72" y="36">i</text><text text-anchor="middle" x="80" y="36">e</text><text text-anchor="middle" x="88" y="36">r</text><text text-anchor="middle" x="16" y="68">M</text><text text-anchor="middle" x="24" y="68">i</text><text text-anchor="middle" x="32" y="68">s</text><text text-anchor="middle" x="40" y="68">s</text><text text-anchor="middle" x="16" y="84">I</text><text text-anchor="middle" x="24" y="84">d</text><text text-anchor="middle" x="32" y="84">e</text><text text-anchor="middle" x="40" y="84">n</text><text text-anchor="middle" x="48" y="84">t</text><text text-anchor="middle" x="56" y="84">i</text><text text-anchor="middle" x="64" y="84">f</text><text text-anchor="middle" x="72" y="84">i</text><text text-anchor="middle" x="80" y="84">e</text><text text-anchor="middle" x="88" y="84">r</text><text text-anchor="middle" x="16" y="116">H</text><text text-anchor="middle" x="24" y="116">i</text><text text-anchor="middle" x="32" y="116">t</text><text text-anchor="middle" x="40" y="116">G</text><text text-anchor="middle" x="48" y="116">r</text><text text-anchor="middle" x="56" y="116">o</text><text text-anchor="middle" x="64" y="116">u</text><text text-anchor="middle" x="72" y="116">p</text><text text-anchor="middle" x="80" y="116">0</text><text text-anchor="middle" x="16" y="132">I</text><text text-anchor="middle" x="24" y="132">d</text><text text-anchor="middle" x="32" y="132">e</text><text text-anchor="middle" x="40" y="132">n</text><text text-anchor="middle" x="48" y="132">t</text><text text-anchor="middle" x="56" y="132">i</text><text text-anchor="middle" x="64" y="132">f</text><text text-anchor="middle" x="72" y="132">i</text><text text-anchor="middle" x="80" y="132">e</text><text text-anchor="middle" x="88" y="132">r</text><text text-anchor="middle" x="16" y="164">T</text><text text-anchor="middle" x="24" y="164">e</text><text text-anchor="middle" x="32" y="164">x</text><text text-anchor="middle" x="40" y="164">t</text><text text-anchor="middle" x="48" y="164">u</text><text text-anchor="middle" x="56" y="164">r</text><text text-anchor="middle" x="64" y="164">e</text><text text-anchor="middle" x="72" y="164">0</text><text text-anchor="middle" x="16" y="180">I</text><text text-anchor="middle" x="24" y="180">n</text><text text-anchor="middle" x="32" y="180">d</text><text text-anchor="middle" x="40" y="180">e</text><text text-anchor="middle" x="48" y="180">x</text><text text-anchor="middle" x="16" y="212">H</text><text text-anchor="middle" x="24" y="212">i</text><text text-anchor="middle" x="32" y="212">t</text><text text-anchor="middle" x="40" y="212">G</text><text text-anchor="middle" x="48" y="212">r</text><text text-anchor="middle" x="56" y="212">o</text><text text-anchor="middle" x="64" y="212">u</text><text text-anchor="middle" x="72" y="212">p</text><text text-anchor="middle" x="80" y="212">1</text><text text-anchor="middle" x="16" y="228">I</text><text text-anchor="middle" x="24" y="228">d</text><text text-anchor="middle" x="32" y="228">e</text><text text-anchor="middle" x="40" y="228">n</text><text text-anchor="middle" x="48" y="228">t</text><text text-anchor="middle" x="56" y="228">i</text><text text-anchor="middle" x="64" y="228">f</text><text text-anchor="middle" x="72" y="228">i</text><text text-anchor="middle" x="80" y="228">e</text><text text-anchor="middle" x="88" y="228">r</text><text text-anchor="middle" x="16" y="260">T</text><text text-anchor="middle" x="24" y="260">e</text><text text-anchor="middle" x="32" y="260">x</text><text text-anchor="middle" x="40" y="260">t</text><text text-anchor="middle" x="48" y="260">u</text><text text-anchor="middle" x="56" y="260">r</text><text text-anchor="middle" x="64" y="260">e</text><text text-anchor="middle" x="72" y="260">1</text><text text-anchor="middle" x="16" y="276">I</text><text text-anchor="middle" x="24" y="276">n</text><text text-anchor="middle" x="32" y="276">d</text><text text-anchor="middle" x="40" y="276">e</text><text text-anchor="middle" x="48" y="276">x</text><text text-anchor="middle" x="16" y="308">H</text><text text-anchor="middle" x="24" y="308">i</text><text text-anchor="middle" x="32" y="308">t</text><text text-anchor="middle" x="40" y="308">G</text><text text-anchor="middle" x="48" y="308">r</text><text text-anchor="middle" x="56" y="308">o</text><text text-anchor="middle" x="64" y="308">u</text><text text-anchor="middle" x="72" y="308">p</text><text text-anchor="middle" x="80" y="308">2</text><text text-anchor="middle" x="16" y="324">I</text><text text-anchor="middle" x="24" y="324">d</text><text text-anchor="middle" x="32" y="324">e</text><text text-anchor="middle" x="40" y="324">n</text><text text-anchor="middle" x="48" y="324">t</text><text text-anchor="middle" x="56" y="324">i</text><text text-anchor="middle" x="64" y="324">f</text><text text-anchor="middle" x="72" y="324">i</text><text text-anchor="middle" x="80" y="324">e</text><text text-anchor="middle" x="88" y="324">r</text><text text-anchor="middle" x="48" y="356">/</text><text text-anchor="middle" x="56" y="356">/</text></g></g></svg>

</p><p>

Note that <code>HitGroup2</code> does not needs any texture index. 
However, the alignment requirements of the SBT force each program type
 (ray generation, miss, hit group) to have a fixed entry size for all of
 its members. The size of the entry for a given program type
 is then driven by the maximum number of pushconstant values within that
 type: 0 for the ray generation, 0 for the miss, and 1 for the
 hit group. Therefore, the SBT entry is padded to respect the alignment.
 

</p><p>

In many practical the ray tracing process uses multiple ray types, for 
example to differentiate between regular rays and shadow rays.
In such cases, the SBT would contain one hit group per ray type, for 
each object type. Going back to a sample with a single object for 
conciseness, adding a second ray type simply requires adding the 
corresponding hit group in the SBT:

</p><p>

<svg class="diagram" xmlns="http://www.w3.org/2000/svg" version="1.1" height="240" width="136" style="margin:0 auto 0 auto;"><g transform="translate(8,16 )">
<path d="M 0,0 L 0,192 " style="fill:none;"></path>
<path d="M 120,0 L 120,192 " style="fill:none;"></path>
<path d="M 0,0 L 120,0 " style="fill:none;"></path>
<path d="M 0,48 L 120,48 " style="fill:none;"></path>
<path d="M 0,96 L 120,96 " style="fill:none;"></path>
<path d="M 0,144 L 120,144 " style="fill:none;"></path>
<path d="M 0,192 L 120,192 " style="fill:none;"></path>
<g transform="translate(0,0)"><text text-anchor="middle" x="16" y="20">R</text><text text-anchor="middle" x="24" y="20">a</text><text text-anchor="middle" x="32" y="20">y</text><text text-anchor="middle" x="40" y="20">G</text><text text-anchor="middle" x="48" y="20">e</text><text text-anchor="middle" x="56" y="20">n</text><text text-anchor="middle" x="16" y="36">I</text><text text-anchor="middle" x="24" y="36">d</text><text text-anchor="middle" x="32" y="36">e</text><text text-anchor="middle" x="40" y="36">n</text><text text-anchor="middle" x="48" y="36">t</text><text text-anchor="middle" x="56" y="36">i</text><text text-anchor="middle" x="64" y="36">f</text><text text-anchor="middle" x="72" y="36">i</text><text text-anchor="middle" x="80" y="36">e</text><text text-anchor="middle" x="88" y="36">r</text><text text-anchor="middle" x="16" y="68">M</text><text text-anchor="middle" x="24" y="68">i</text><text text-anchor="middle" x="32" y="68">s</text><text text-anchor="middle" x="40" y="68">s</text><text text-anchor="middle" x="16" y="84">I</text><text text-anchor="middle" x="24" y="84">d</text><text text-anchor="middle" x="32" y="84">e</text><text text-anchor="middle" x="40" y="84">n</text><text text-anchor="middle" x="48" y="84">t</text><text text-anchor="middle" x="56" y="84">i</text><text text-anchor="middle" x="64" y="84">f</text><text text-anchor="middle" x="72" y="84">i</text><text text-anchor="middle" x="80" y="84">e</text><text text-anchor="middle" x="88" y="84">r</text><text text-anchor="middle" x="16" y="116">H</text><text text-anchor="middle" x="24" y="116">i</text><text text-anchor="middle" x="32" y="116">t</text><text text-anchor="middle" x="40" y="116">G</text><text text-anchor="middle" x="48" y="116">r</text><text text-anchor="middle" x="56" y="116">o</text><text text-anchor="middle" x="64" y="116">u</text><text text-anchor="middle" x="72" y="116">p</text><text text-anchor="middle" x="16" y="132">I</text><text text-anchor="middle" x="24" y="132">d</text><text text-anchor="middle" x="32" y="132">e</text><text text-anchor="middle" x="40" y="132">n</text><text text-anchor="middle" x="48" y="132">t</text><text text-anchor="middle" x="56" y="132">i</text><text text-anchor="middle" x="64" y="132">f</text><text text-anchor="middle" x="72" y="132">i</text><text text-anchor="middle" x="80" y="132">e</text><text text-anchor="middle" x="88" y="132">r</text><text text-anchor="middle" x="16" y="164">S</text><text text-anchor="middle" x="24" y="164">h</text><text text-anchor="middle" x="32" y="164">a</text><text text-anchor="middle" x="40" y="164">d</text><text text-anchor="middle" x="48" y="164">o</text><text text-anchor="middle" x="56" y="164">w</text><text text-anchor="middle" x="64" y="164">G</text><text text-anchor="middle" x="72" y="164">r</text><text text-anchor="middle" x="80" y="164">o</text><text text-anchor="middle" x="88" y="164">u</text><text text-anchor="middle" x="96" y="164">p</text><text text-anchor="middle" x="16" y="180">I</text><text text-anchor="middle" x="24" y="180">d</text><text text-anchor="middle" x="32" y="180">e</text><text text-anchor="middle" x="40" y="180">n</text><text text-anchor="middle" x="48" y="180">t</text><text text-anchor="middle" x="56" y="180">i</text><text text-anchor="middle" x="64" y="180">f</text><text text-anchor="middle" x="72" y="180">i</text><text text-anchor="middle" x="80" y="180">e</text><text text-anchor="middle" x="88" y="180">r</text></g></g></svg>

</p><p>

How the pipeline associates a geometry with a hit group depends on the hit group index used when adding an instance to the 
top-level AS helper class. Internally, this index maps to the <code>instanceOffset</code> of the <code>VkGeometryInstance</code>
object.

</p><p>

Getting back to our sample, none of our shaders use pushconstant values.
 We then simply add the shader program indices to the SBT, without any 
additional values:
</p><pre class="listing tilde"><code><span class="hljs-comment">//--------------------------------------------------------------------------------------------------</span>
<span class="hljs-comment">// Create the shader binding table, associating the geometry to the indices of the shaders in the</span>
<span class="hljs-comment">// ray tracing pipeline</span>
<span class="hljs-keyword">void</span> HelloVulkan::createShaderBindingTable()
{
  <span class="hljs-comment">// Add the entry point, the ray generation program</span>
  m_sbtGen.AddRayGenerationProgram(m_rayGenIndex, {});
  <span class="hljs-comment">// Add the miss shader for the camera rays</span>
  m_sbtGen.AddMissProgram(m_missIndex, {});

  <span class="hljs-comment">// For each instance, we will have 1 hit group for the camera rays.</span>
  <span class="hljs-comment">// When setting the instances in the top-level acceleration structure we indicated the index</span>
  <span class="hljs-comment">// of the hit group in the shader binding table that will be invoked. </span>

  <span class="hljs-comment">// Add the hit group defining the behavior upon hitting a surface with a camera ray</span>
  m_sbtGen.AddHitGroup(m_hitGroupIndex, {});</code></pre><p>

From the number of shaders, we can query the helper object to know the 
size of the SBT, and allocate the corresponding buffer as host visible:
the helper will use mapping to write the contents of the SBT. As an 
exercise, it is then possible to copy the data to a GPU-only buffer for 
performance. 
</p><pre class="listing tilde"><code>  <span class="hljs-comment">// Compute the required size for the SBT</span>
  VkDeviceSize shaderBindingTableSize = m_sbtGen.ComputeSBTSize(m_raytracingProperties);

  <span class="hljs-comment">// Allocate mappable memory to store the SBT</span>
  nv_helpers_vk::createBuffer(VkCtx.getPhysicalDevice(), VkCtx.getDevice(), shaderBindingTableSize,
                              VK_BUFFER_USAGE_TRANSFER_SRC_BIT, &amp;m_shaderBindingTableBuffer,
                              &amp;m_shaderBindingTableMem, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT);</code></pre><p>

The <code>Generate</code> call will populate the Shader Binding Table: in our case it will simply copy the shader identifiers obtained by <code>vkGetRayTracingShaderGroupHandlesNV</code>
into the target buffer.
</p><pre class="listing tilde"><code>  <span class="hljs-comment">// Generate the SBT using mapping. For further performance a staging buffer should be used, so</span>
  <span class="hljs-comment">// that the SBT is guaranteed to reside on GPU memory without overheads.</span>
  m_sbtGen.Generate(VkCtx.getDevice(), m_rtPipeline, m_shaderBindingTableBuffer,
                    m_shaderBindingTableMem);
}</code></pre>
<a class="target" name="main">&nbsp;</a><h2>main</h2>
<p>

In the <code>main</code> function, add the construction of the Shader Binding Table:
</p><pre class="listing tilde"><code><span class="hljs-selector-tag">helloVulkan</span><span class="hljs-selector-class">.createShaderBindingTable</span>();</code></pre>
<a class="target" name="let'sraytrace!">&nbsp;</a><h1>Let's Raytrace!</h1>
<p>


Now we have everything setup to be able to trace rays: the acceleration 
structure, the descriptor set, the ray tracing pipeline and the shader 
binding table. Let's try to 
make images from this. 

</p>
<a class="target" name="main">&nbsp;</a><h2>main</h2>
<p>

In the <code>main</code> function, we will define a local variable that 
we will use to decide whether we want to rasterize or raytrace our 
scene. Add the following right after 
the ray tracing initialization calls:
</p><pre class="listing tilde"><code><span class="hljs-type">bool</span> use_raster_render = <span class="hljs-literal">true</span>;</code></pre><p>

In the same function, find the line <code>ImGui::ColorEdit3(</code> and, right after that call, add 
</p><pre class="listing tilde"><code>ImGui::Checkbox(<span class="hljs-string">"Raster mode"</span>,
  &amp;use_raster_render); <span class="hljs-regexp">//</span> Switch between raster <span class="hljs-keyword">and</span> ray tracing</code></pre><p>

A few lines below, you can find a <code>if (1==1)</code> block containing the rasterization calls. Replace that condition by 
</p><pre class="listing tilde"><code>if (<span class="hljs-name">use_raster_render</span>)</code></pre><p>

At the end of that <code>if</code> block, we can now put a <code>else</code>
 block that will call ray tracing. As explained before, ray tracing 
cannot
write directly to the render target, and uses another buffer for that 
purpose. This ray tracing output buffer then needs to be copied
into the render target. We start the ray tracing path by ensuring the 
ray tracing output image can be written using a barrier:
</p><pre class="listing tilde"><code><span class="hljs-keyword">else</span>
{
  VkClearValue clearColor = {<span class="hljs-number">0</span>.0f, <span class="hljs-number">0</span>.<span class="hljs-number">5</span>f, <span class="hljs-number">0</span>.0f, <span class="hljs-number">1.0</span>f};

  VkImageSubresourceRange subresourceRange;
  subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
  subresourceRange.baseMipLevel = <span class="hljs-number">0</span>;
  subresourceRange.levelCount = <span class="hljs-number">1</span>;
  subresourceRange.baseArrayLayer = <span class="hljs-number">0</span>;
  subresourceRange.layerCount = <span class="hljs-number">1</span>;

  nv_helpers_vk::imageBarrier(cmdBuff, helloVulkan.m_rtOutputImage, subresourceRange, <span class="hljs-number">0</span>,
                              VK_ACCESS_SHADER_WRITE_BIT, VK_IMAGE_LAYOUT_UNDEFINED,
                              VK_IMAGE_LAYOUT_GENERAL);</code></pre><p>

We then bind the ray tracing pipeline and the descriptor set to allow the shaders to access their resources:
</p><pre class="listing tilde"><code>  vkCmdBindPipeline(<span class="hljs-name">cmdBuff</span>, VK_PIPELINE_BIND_POINT_RAY_TRACING_NV, helloVulkan.m_rtPipeline)<span class="hljs-comment">;</span>

  vkCmdBindDescriptorSets(<span class="hljs-name">cmdBuff</span>, VK_PIPELINE_BIND_POINT_RAY_TRACING_NV,
                          helloVulkan.m_rtPipelineLayout, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-symbol">&amp;helloVulkan</span>.m_rtDescriptorSet,
                          <span class="hljs-number">0</span>, nullptr)<span class="hljs-comment">;</span></code></pre><p>

The ray tracing itself can then be added on the command buffer by calling <code>vkCmdTraceRaysNV</code>.
 This function requires 
the shader binding table, and offsets to indicate where the ray 
generation, miss and hit groups can be found. Note that
our helper puts all shaders in a single SBT, but the API allows having 
one table per shader type. For each type, we also provide 
the stride, which is the size of a SBT entry for that type. The offsets 
and strides are provided by the SBT generation helper 
to ensure consistenty.
</p><pre class="listing tilde"><code>  VkDeviceSize rayGenOffset = helloVulkan.m_sbtGen.GetRayGenOffset();
  VkDeviceSize missOffset = helloVulkan.m_sbtGen.GetMissOffset();
  VkDeviceSize missStride = helloVulkan.m_sbtGen.GetMissEntrySize();
  VkDeviceSize hitGroupOffset = helloVulkan.m_sbtGen.GetHitGroupOffset();
  VkDeviceSize hitGroupStride = helloVulkan.m_sbtGen.GetHitGroupEntrySize();

  vkCmdTraceRaysNV(cmdBuff, helloVulkan.m_shaderBindingTableBuffer, rayGenOffset,
                   helloVulkan.m_shaderBindingTableBuffer, missOffset, missStride,
                   helloVulkan.m_shaderBindingTableBuffer, hitGroupOffset, hitGroupStride,
                   VK_NULL_HANDLE, 0, 0,
                   helloVulkan.m_framebufferSize.width, helloVulkan.m_framebufferSize.height, 1);</code></pre><p>

After ray tracing, we then ensure the output is finished writing, and copy the result into the render target. 
</p><pre class="listing tilde"><code>  nv_helpers_vk::imageBarrier(cmdBuff, VkCtx.getCurrentBackBuffer(), subresourceRange, <span class="hljs-number">0</span>,
                              VK_ACCESS_TRANSFER_WRITE_BIT, VK_IMAGE_LAYOUT_UNDEFINED,
                              VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);

  nv_helpers_vk::imageBarrier(cmdBuff, helloVulkan.m_rtOutputImage, subresourceRange,
                              VK_ACCESS_SHADER_WRITE_BIT, VK_ACCESS_TRANSFER_READ_BIT,
                              VK_IMAGE_LAYOUT_GENERAL, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL);

  VkImageCopy copyRegion;
  copyRegion.srcSubresource = {VK_IMAGE_ASPECT_COLOR_BIT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>};
  copyRegion.srcOffset = {<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>};
  copyRegion.dstSubresource = {VK_IMAGE_ASPECT_COLOR_BIT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>};
  copyRegion.dstOffset = {<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>};
  copyRegion.extent = {helloVulkan.m_framebufferSize.width,
                       helloVulkan.m_framebufferSize.height, <span class="hljs-number">1</span>};
  vkCmdCopyImage(cmdBuff, helloVulkan.m_rtOutputImage, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
                 VkCtx.getCurrentBackBuffer(), VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, <span class="hljs-number">1</span>,
                 ©Region);

  nv_helpers_vk::imageBarrier(
      cmdBuff, VkCtx.getCurrentBackBuffer(), subresourceRange, VK_ACCESS_TRANSFER_WRITE_BIT, <span class="hljs-number">0</span>,
      VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_PRESENT_SRC_KHR);
}</code></pre><p>

We should now be able to alternate between rasterization and ray 
tracing. However, the ray tracing result only renders a flat gray image:
 the simplistic ray generation shader 
does not trace any ray yet, and simply returns a fixed color. 
</p><div class="table"><table class="table"><tbody><tr><th style="text-align:center"> Raster </th><th style="text-align:center">  </th><th style="text-align:center"> Ray-trace </th></tr>
<tr><td style="text-align:center"> <a href="https://developer.nvidia.com/sites/default/files/pictures/2019/vulkan_raytracing/resultRasterCube.png" target="_blank"><img class="markdeep" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/resultRasterCube.png" width="350px"></a> </td><td style="text-align:center"> ↔ </td><td style="text-align:center"> <a href="https://developer.nvidia.com/sites/default/files/pictures/2019/vulkan_raytracing/resultRaytraceEmptyCube.png" target="_blank"><img class="markdeep" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/resultRaytraceEmptyCube.png" width="350px"></a> </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="camerasetup">&nbsp;</a><h1>Camera Setup</h1>
<p>


In the context of rasterization, the vertices of the objects are projected from their world-space position into a <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-1-Frame" tabindex="0" style="position: relative;" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mo stretchy=&quot;false&quot;&gt;[&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;]&lt;/mo&gt;&lt;mo&gt;&amp;#x00D7;&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;[&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;]&lt;/mo&gt;&lt;mo&gt;&amp;#x00D7;&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;[&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;]&lt;/mo&gt;&lt;/math&gt;" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-1" style="width: 9.916em; display: inline-block;"><span style="display: inline-block; position: relative; width: 8.513em; height: 0px; font-size: 116%;"><span style="position: absolute; clip: rect(1.749em, 1008.43em, 2.904em, -1000em); top: -2.586em; left: 0em;"><span class="mrow" id="MathJax-Span-2"><span class="mo" id="MathJax-Span-3" style="font-family: STIXGeneral;">[</span><span class="mn" id="MathJax-Span-4" style="font-family: STIXGeneral;">0</span><span class="mo" id="MathJax-Span-5" style="font-family: STIXGeneral;">,</span><span class="mn" id="MathJax-Span-6" style="font-family: STIXGeneral; padding-left: 0.188em;">1</span><span class="mo" id="MathJax-Span-7" style="font-family: STIXGeneral;">]</span><span class="mo" id="MathJax-Span-8" style="font-family: STIXGeneral; padding-left: 0.25em;">×</span><span class="mo" id="MathJax-Span-9" style="font-family: STIXGeneral; padding-left: 0.25em;">[</span><span class="mn" id="MathJax-Span-10" style="font-family: STIXGeneral;">0</span><span class="mo" id="MathJax-Span-11" style="font-family: STIXGeneral;">,</span><span class="mn" id="MathJax-Span-12" style="font-family: STIXGeneral; padding-left: 0.188em;">1</span><span class="mo" id="MathJax-Span-13" style="font-family: STIXGeneral;">]</span><span class="mo" id="MathJax-Span-14" style="font-family: STIXGeneral; padding-left: 0.25em;">×</span><span class="mo" id="MathJax-Span-15" style="font-family: STIXGeneral; padding-left: 0.25em;">[</span><span class="mn" id="MathJax-Span-16" style="font-family: STIXGeneral;">0</span><span class="mo" id="MathJax-Span-17" style="font-family: STIXGeneral;">,</span><span class="mn" id="MathJax-Span-18" style="font-family: STIXGeneral; padding-left: 0.188em;">1</span><span class="mo" id="MathJax-Span-19" style="font-family: STIXGeneral;">]</span></span><span style="display: inline-block; width: 0px; height: 2.586em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.243em; border-left: 0px solid; width: 0px; height: 1.09em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo><mo>×</mo><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo><mo>×</mo><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></math></span></span><script type="math/tex" id="MathJax-Element-1">[0,1]\times[0,1]\times[0,1]</script>
 cube, before being rasterized on the XY plane. 
For ray tracing, we need to initialize some rays at the camera position,
 and intersect the geometry in world space. To achieve this, we need to 
store the inverse view and projection matrices.
In the <code>UniformBufferObject</code> at the beginning of the <code>hello_vulkan.cpp</code> file, add the inverse matrices so that the structure now is:
</p><pre class="listing tilde"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UniformBufferObject</span>
{</span>
  glm::mat4 model;
  glm::mat4 view;
  glm::mat4 proj;
  glm::mat4 modelIT;
  <span class="hljs-comment">// #VKRT</span>
  glm::mat4 viewInverse;
  glm::mat4 projInverse;
};</code></pre>
<a class="target" name="updateuniformbuffer">&nbsp;</a><h2>updateUniformBuffer</h2>
<p>

The computation of the matrix inverses is done in <code>updateUniformBuffer</code>, after setting the <code>ubo.proj</code> matrix:
</p><pre class="listing tilde"><code><span class="hljs-comment">// #VKRT</span>
ubo.viewInverse = glm::<span class="hljs-built_in">inverse</span>(ubo.view);
ubo.projInverse = glm::<span class="hljs-built_in">inverse</span>(ubo.proj);</code></pre>
<a class="target" name="raygen.rgen">&nbsp;</a><h2>raygen.rgen</h2>
<p>


It is now time to enrich the ray generation shader to allow it to trace 
rays. We will first add a new binding to allow the shader 
to access the camera matrices:
</p><pre class="listing tilde"><code><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span>=<span class="hljs-number">2</span>) <span class="hljs-keyword">uniform</span> CameraProperties
{
    <span class="hljs-type">mat4</span> model;
    <span class="hljs-type">mat4</span> view;
    <span class="hljs-type">mat4</span> proj;
    <span class="hljs-type">mat4</span> modelIT;
    <span class="hljs-type">mat4</span> viewInverse;
    <span class="hljs-type">mat4</span> projInverse;
} cam;</code></pre><p>

When tracing a ray, the hit or miss shaders need to be able to return 
some information to the shader program that invoked the ray tracing. 
This 
is done through the use of a payload, identified by the <code>rayPayloadNV</code> qualifier. 
</p><pre class="listing tilde"><code><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) rayPayloadNV <span class="hljs-type">vec3</span> hitValue;</code></pre><p>

The <code>main</code> function of the shader then starts by the computation of the floating-point pixel coordinates, normalized between 0 and 1. The <code>gl_LaunchIDNV</code>
contains the integer coordinates of the pixel being rendered, while <code>gl_LaunchSizeNV</code> corresdonds to the image size provided when calling <code>vkCmdTraceRaysNV</code>.
</p><pre class="listing tilde"><code><span class="hljs-type">void</span> main() 
{
    <span class="hljs-keyword">const</span> <span class="hljs-type">vec2</span> pixelCenter = <span class="hljs-type">vec2</span>(gl_LaunchIDNV.xy) + <span class="hljs-type">vec2</span>(<span class="hljs-number">0.5</span>);
    <span class="hljs-keyword">const</span> <span class="hljs-type">vec2</span> inUV = pixelCenter/<span class="hljs-type">vec2</span>(gl_LaunchSizeNV.xy);
    <span class="hljs-type">vec2</span> d = inUV * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>;</code></pre><p>

From the pixel coordinates, we can apply the inverse transformation of 
the view and projection matrices of the camera to obtain the origin and 
direction of the ray. 
</p><pre class="listing tilde"><code>    <span class="hljs-type">vec4</span> origin = cam.viewInverse*<span class="hljs-type">vec4</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);
    <span class="hljs-type">vec4</span> target = cam.projInverse * <span class="hljs-type">vec4</span>(d.x, d.y, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) ;
    <span class="hljs-type">vec4</span> direction = cam.viewInverse*<span class="hljs-type">vec4</span>(<span class="hljs-built_in">normalize</span>(target.xyz), <span class="hljs-number">0</span>) ;</code></pre><p>

In addition, we provide some flags for the ray: a flag indicating, in this case, that all geometry will be considered opaque, 
a mask that will be binary AND-ed with the mask of the geometry instances. Since all instances have a <code>0xFF</code>
 flag as well, they will
all be visible. We also indicate the minimum and maximum distance of the
 potential intersections along the ray. This allows, for example
to use short, inexpensive rays for ambient occlusion computations. 
</p><pre class="listing tilde"><code>    <span class="hljs-type">uint</span> rayFlags = gl_RayFlagsOpaqueNV;
    <span class="hljs-type">uint</span> cullMask = <span class="hljs-number">0xff</span>;
    <span class="hljs-type">float</span> tmin = <span class="hljs-number">0.001</span>;
    <span class="hljs-type">float</span> tmax = <span class="hljs-number">10000.0</span>;</code></pre><p>

We now trace the ray itself, by first providing <code>traceNV</code> 
with the top-level acceleration structure and the ray masks. The next 3 
parameters
indicate which hit group would be called when hitting a surface. For 
example, a single object may be associated to 2 hit groups representing
the behavior when hit by a direct camera ray, or from a shadow ray. 
Since each instance has an index indicating the offset of the hit groups
 
for the instance in the shader binding table, the <code>sbtRecordOffset</code>
 will allow to fetch the right kind of shader for that instance. In the 
case
of the primary rays we may want to use the first hit group and use an 
offset of 0, while for shadow rays the second hit group would be 
required, hence
an offset of 1. The stride indicates the number of hit groups for a 
single instance. This is particularly useful if the instance offset is 
not set 
when creating the instances in the acceleration structure. A stride of 0
 indicates that all hit groups are packed together, and the instance 
offset can 
be used directly to find them in the SBT. The index of the miss shader 
comes next, followed by the ray origin, direction and extents. The last 
parameter 
identifies the payload that will be carried by the ray, by giving its 
location index. The 0 corresponds to our payload definition above, <code>layout(location = 0) rayPayloadNV vec3 hitValue;</code>.
</p><pre class="listing tilde"><code><span class="hljs-selector-tag">traceNV</span>(<span class="hljs-selector-tag">topLevelAS</span>, <span class="hljs-selector-tag">rayFlags</span>, <span class="hljs-selector-tag">cullMask</span>, 0 <span class="hljs-comment">/*sbtRecordOffset*/</span>, 0 <span class="hljs-comment">/*sbtRecordStride*/</span>,
0 <span class="hljs-comment">/*missIndex*/</span>, <span class="hljs-selector-tag">origin</span><span class="hljs-selector-class">.xyz</span>, <span class="hljs-selector-tag">tmin</span>, <span class="hljs-selector-tag">direction</span><span class="hljs-selector-class">.xyz</span>, <span class="hljs-selector-tag">tmax</span>, 0 <span class="hljs-comment">/*payload*/</span>);</code></pre><p>
Finally, we write the resulting payload into the output buffer. 
</p><pre class="listing tilde"><code>    <span class="hljs-built_in">imageStore</span>(image, <span class="hljs-type">ivec2</span>(gl_LaunchIDNV.xy), <span class="hljs-type">vec4</span>(hitValue, <span class="hljs-number">0.0</span>));
}</code></pre><p>
</p><div class="table"><table class="table"><tbody><tr><th style="text-align:center"> Raster </th><th style="text-align:center">  </th><th style="text-align:center"> Ray-trace </th></tr>
<tr><td style="text-align:center"> <a href="https://developer.nvidia.com/sites/default/files/pictures/2019/vulkan_raytracing/resultRasterCube.png" target="_blank"><img class="markdeep" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/resultRasterCube.png" width="350px"></a> </td><td style="text-align:center"> ↔ </td><td style="text-align:center"> <a href="https://developer.nvidia.com/sites/default/files/pictures/2019/vulkan_raytracing/resultRaytraceFlatCube.png" target="_blank"><img class="markdeep" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/resultRaytraceFlatCube.png" width="350px"></a> </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="simplelighting">&nbsp;</a><h1>Simple Lighting</h1>
<p>


The current closest hit shader only returns a flat color. To add some 
lighting, we will need to introduce the concept of
surface normals. However, the ray tracing only provides the barycentric 
coordinates of the hit point. To obtain the normals and the
other vertex attributes, we will need to find them in the vertex buffer 
and interpolate them using the barycentric coordinates. This requires
changing the implementation of the methods of <code>hello_vulkan.cpp</code> as follows:

</p>
<a class="target" name="createvertexbuffer">&nbsp;</a><h2>createVertexBuffer</h2>
<p>


When creating the vertex buffer, we must now indicate that this buffer 
will be used not only as a vertex buffer, but also as a regular
storage buffer. Replace the second call to <code>VkCtx.createBuffer</code> by
</p><pre class="listing tilde"><code>VkCtx.createBuffer(bufferSize,
VK_BUFFER_USAGE_TRANSFER_DST_BIT |
    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT
    // <span class="hljs-comment">#VKRT</span>
    | VK_BUFFER_USAGE_STORAGE_BUFFER_BIT,
VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, m_vertexBuffer, m_vertexBufferMemory);</code></pre>
<a class="target" name="createindexbuffer">&nbsp;</a><h2>createIndexBuffer</h2>
<p>

Similarly for the index buffer, replace the second call to <code>VkCtx.createBuffer</code> by
</p><pre class="listing tilde"><code>VkCtx.createBuffer(bufferSize,
VK_BUFFER_USAGE_TRANSFER_DST_BIT |
    VK_BUFFER_USAGE_INDEX_BUFFER_BIT
    // <span class="hljs-comment">#VKRT</span>
    | VK_BUFFER_USAGE_STORAGE_BUFFER_BIT,
VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, m_indexBuffer, m_indexBufferMemory);</code></pre>
<a class="target" name="closesthit.rchit">&nbsp;</a><h2>closesthit.rchit</h2>
<p>

When we 
created the ray tracing descriptor set, we already included the geometry
 definition. Therefore, we can reference the vertex and index buffers
directly in the closest hit shader. 
</p><pre class="listing tilde"><code><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">3</span>) <span class="hljs-keyword">buffer</span> Vertices { <span class="hljs-type">vec4</span> v[]; }
<span class="hljs-keyword">vertices</span>;
<span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">4</span>) <span class="hljs-keyword">buffer</span> Indices { <span class="hljs-type">uint</span> i[]; }
indices;</code></pre><p>

The vertex buffer is defined as a simple array of <code>vec4</code> values. For improved readability, we replicate the vertex structure
of the source file:
</p><pre class="listing tilde"><code>struct Vertex
{
  <span class="hljs-type">vec3</span> pos;
  <span class="hljs-type">vec3</span> nrm;
  <span class="hljs-type">vec3</span> color;
  <span class="hljs-type">vec2</span> texCoord;
  <span class="hljs-type">int</span> matIndex;
};
<span class="hljs-comment">// Number of vec4 values used to represent a vertex</span>
<span class="hljs-type">uint</span> vertexSize = <span class="hljs-number">3</span>;</code></pre><p>

We can then add a helper function to unpack the data of a given vertex into a <code>Vertex</code> structure:
</p><pre class="listing tilde"><code>Vertex unpackVertex(<span class="hljs-type">uint</span> <span class="hljs-keyword">index</span>)
{
  Vertex v;

  <span class="hljs-type">vec4</span> d0 = <span class="hljs-keyword">vertices</span>.v[vertexSize * <span class="hljs-keyword">index</span> + <span class="hljs-number">0</span>];
  <span class="hljs-type">vec4</span> d1 = <span class="hljs-keyword">vertices</span>.v[vertexSize * <span class="hljs-keyword">index</span> + <span class="hljs-number">1</span>];
  <span class="hljs-type">vec4</span> d2 = <span class="hljs-keyword">vertices</span>.v[vertexSize * <span class="hljs-keyword">index</span> + <span class="hljs-number">2</span>];

  v.pos = d0.xyz;
  v.nrm = <span class="hljs-type">vec3</span>(d0.w, d1.x, d1.y);
  v.color = <span class="hljs-type">vec3</span>(d1.z, d1.w, d2.x);
  v.texCoord = <span class="hljs-type">vec2</span>(d2.y, d2.z);
  v.matIndex = <span class="hljs-built_in">floatBitsToInt</span>(d2.w);
  <span class="hljs-keyword">return</span> v;
}</code></pre><p>

In the <code>main</code> function, the <code>gl_PrimitiveID</code> allows us to find the vertices of the triangle hit by the ray:
</p><pre class="listing tilde"><code><span class="hljs-type">void</span> main()
{

  <span class="hljs-type">ivec3</span> ind = <span class="hljs-type">ivec3</span>(indices.i[<span class="hljs-number">3</span> * <span class="hljs-built_in">gl_PrimitiveID</span>], indices.i[<span class="hljs-number">3</span> * <span class="hljs-built_in">gl_PrimitiveID</span> + <span class="hljs-number">1</span>],
                    indices.i[<span class="hljs-number">3</span> * <span class="hljs-built_in">gl_PrimitiveID</span> + <span class="hljs-number">2</span>]);

  Vertex v0 = unpackVertex(ind.x);
  Vertex v1 = unpackVertex(ind.y);
  Vertex v2 = unpackVertex(ind.z);</code></pre><p>

Using the barycentric coordinates, we can interpolate the normal:
</p><pre class="listing tilde"><code>  <span class="hljs-keyword">const</span> <span class="hljs-type">vec3</span> barycentrics = <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span> - attribs.x - attribs.y, attribs.x, attribs.y);

  <span class="hljs-type">vec3</span> normal =
      <span class="hljs-built_in">normalize</span>(v0.nrm * barycentrics.x + v1.nrm * barycentrics.y + v2.nrm * barycentrics.z);</code></pre><p>

The hardcoded directional light source can then be used to compute the dot product of the normal with the lighting direction,
giving a simple diffuse lighting effect:
</p><pre class="listing tilde"><code>  <span class="hljs-type">vec3</span> lightVector = <span class="hljs-built_in">normalize</span>(<span class="hljs-type">vec3</span>(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>));

  <span class="hljs-type">float</span> dot_product = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(lightVector, normal), <span class="hljs-number">0.2</span>);

  hitValue = <span class="hljs-type">vec3</span>(dot_product); 
}</code></pre><p>

</p><center><a href="https://developer.nvidia.com/sites/default/files/pictures/2019/vulkan_raytracing/resultRaytraceLightGreyCube.png" target="_blank"><img class="markdeep" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/resultRaytraceLightGreyCube.png"></a></center> 

<p></p>
<a class="target" name="simplematerials">&nbsp;</a><h1>Simple Materials</h1>
<p>


The rendering above could be made more interesting by adding support for materials. The imported OBJ objects provide 
the simplistic Wavefront material definition. 

</p>
<a class="target" name="closesthit.rchit">&nbsp;</a><h2>closesthit.rchit</h2>
<p>


The materials define the basic reflectance properties using simple color
 coefficients, and also support texturing. The buffer containing 
the materials has already been created for rasterization, and has also 
been added into the ray tracing descriptor set. Add binding of the 
material buffer
and the array of texture samplers:
</p><pre class="listing tilde"><code><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">5</span>) <span class="hljs-keyword">buffer</span> MatColorBufferObject { <span class="hljs-type">vec4</span>[] m; }
materials;
<span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">6</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span>[] textureSamplers;</code></pre><p>
As for the geometry data, the material data is packed into an array of <code>vec4</code> values. We declare the material structure and an
unpacking helper:
</p><pre class="listing tilde"><code>struct WaveFrontMaterial
{
  <span class="hljs-type">vec3</span> ambient;
  <span class="hljs-type">vec3</span> diffuse;
  <span class="hljs-type">vec3</span> specular;
  <span class="hljs-type">vec3</span> transmittance;
  <span class="hljs-type">vec3</span> emission;
  <span class="hljs-type">float</span> shininess;
  <span class="hljs-type">float</span> ior;      <span class="hljs-comment">// index of refraction</span>
  <span class="hljs-type">float</span> dissolve; <span class="hljs-comment">// 1 == opaque; 0 == fully transparent</span>
  <span class="hljs-type">int</span> illum;      <span class="hljs-comment">// illumination model (see http://www.fileformat.info/format/material/)</span>
  <span class="hljs-type">int</span> textureId;
};
<span class="hljs-comment">// Number of vec4 values used to represent a material</span>
<span class="hljs-keyword">const</span> <span class="hljs-type">int</span> sizeofMat = <span class="hljs-number">5</span>;</code></pre><pre class="listing tilde"><code>WaveFrontMaterial unpackMaterial(<span class="hljs-type">int</span> matIndex)
{
  WaveFrontMaterial m;
  <span class="hljs-type">vec4</span> d0 = materials.m[sizeofMat * matIndex + <span class="hljs-number">0</span>];
  <span class="hljs-type">vec4</span> d1 = materials.m[sizeofMat * matIndex + <span class="hljs-number">1</span>];
  <span class="hljs-type">vec4</span> d2 = materials.m[sizeofMat * matIndex + <span class="hljs-number">2</span>];
  <span class="hljs-type">vec4</span> d3 = materials.m[sizeofMat * matIndex + <span class="hljs-number">3</span>];
  <span class="hljs-type">vec4</span> d4 = materials.m[sizeofMat * matIndex + <span class="hljs-number">4</span>];

  m.ambient = <span class="hljs-type">vec3</span>(d0.x, d0.y, d0.z);
  m.diffuse = <span class="hljs-type">vec3</span>(d0.w, d1.x, d1.y);
  m.specular = <span class="hljs-type">vec3</span>(d1.z, d1.w, d2.x);
  m.transmittance = <span class="hljs-type">vec3</span>(d2.y, d2.z, d2.w);
  m.emission = <span class="hljs-type">vec3</span>(d3.x, d3.y, d3.z);
  m.shininess = d3.w;
  m.ior = d4.x;
  m.dissolve = d4.y;
  m.illum = <span class="hljs-type">int</span>(d4.z);
  m.textureId = <span class="hljs-built_in">floatBitsToInt</span>(d4.w);
  <span class="hljs-keyword">return</span> m;
}</code></pre><p>

In the <code>main</code> function, let's start by removing the line writing the output payload <code>hitValue = vec3(dot_product);</code>.
The <code>Vertex</code> structure contains a material index, that we will use to find the corresponding material in the buffer. At the end of the 
<code>main</code> function, add:
</p><pre class="listing tilde"><code>WaveFrontMaterial mat = unpackMaterial(<span class="hljs-name">v1</span>.matIndex)<span class="hljs-comment">;</span></code></pre><p>

From that material, we can obtain the diffuse reflectance and use it to 
compute diffuse lighting. Here we also add support for textures to 
modulate the surface albedo.
</p><pre class="listing tilde"><code><span class="hljs-type">vec3</span> c = dot_product * mat.diffuse; 
<span class="hljs-keyword">if</span> (mat.textureId &gt;= <span class="hljs-number">0</span>)
{
  <span class="hljs-type">vec2</span> texCoord = v0.texCoord * barycentrics.x + v1.texCoord * barycentrics.y +
                            v2.texCoord * barycentrics.z;
  c *= <span class="hljs-built_in">texture</span>(textureSamplers[mat.textureId], texCoord).xyz;
}</code></pre><p>

We can now write the payload:
</p><pre class="listing tilde"><code><span class="hljs-attr">hitValue</span> = c;</code></pre><p>

</p><center><a href="https://developer.nvidia.com/sites/default/files/pictures/2019/vulkan_raytracing/resultRaytraceLightMatCube.png" target="_blank"><img class="markdeep" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/resultRaytraceLightMatCube.html"></a></center> 

<p></p>
<a class="target" name="main">&nbsp;</a><h2>main</h2>
<p>

For a more interesting model, go to the <code>main.cpp</code> file, find the line with <code> helloVulkan.loadModel(</code> and replace it by
</p><pre class="listing tilde"><code>helloVulkan.loadModel(<span class="hljs-string">"../media/scenes/Medieval_building.obj"</span>);</code></pre><p>

Since that model is larger, we can change the <code>CameraManip.setLookat</code> call to
</p><pre class="listing tilde"><code><span class="hljs-selector-tag">CameraManip</span><span class="hljs-selector-class">.setLookat</span>(<span class="hljs-selector-tag">glm</span><span class="hljs-selector-pseudo">::vec3(4.0f</span>, 4<span class="hljs-selector-class">.0f</span>, 4<span class="hljs-selector-class">.0f</span>), <span class="hljs-selector-tag">glm</span><span class="hljs-selector-pseudo">::vec3(0</span>, 0, 0), <span class="hljs-selector-tag">glm</span><span class="hljs-selector-pseudo">::vec3(0</span>, 1, 0));</code></pre><p>

</p><center><a href="https://developer.nvidia.com/sites/default/files/pictures/2019/vulkan_raytracing/resultRaytraceLightMatMedieval.png" target="_blank"><img class="markdeep" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/resultRaytraceLightMatMedieval.png"></a></center> 

<p></p>
<a class="target" name="shadows">&nbsp;</a><h1>Shadows</h1>
<p>


The above allows us to raytrace a scene and apply some lighting, but it is still missing shadowing. To this end, 
we will need to add a new ray type, and shoot rays from the closest hit shaders. This new ray type will require adding
a miss shader and a hit group. 

</p><p>

In the header file, add the indices of the new shaders:
</p><pre class="listing tilde"><code><span class="hljs-keyword">uint32_t</span> m_shadowMissIndex;
<span class="hljs-keyword">uint32_t</span> m_shadowHitGroupIndex;</code></pre>
<a class="target" name="createraytracingpipeline">&nbsp;</a><h2>createRaytracingPipeline</h2>
<p>


Adding a new ray type means adding a new hit group per geometry, and a new miss shader. 

</p><p>

</p><div class="admonition note"><div class="admonition-title"> Shaders (<a href="https://developer.nvidia.com/rtx/raytracing/vkrt_helpers/files/shadowShaders.zip">Download</a>)</div>

<p></p><p>

    Download the shaders and extract the content to the <code>shaders</code> folder.</p></div>

<p></p><p>

The archive contains two files: <code>shadowClosestHit.rchit</code> and <code>shadowMiss.rmiss</code>. Add those files in the <code>shaders</code> filter of the Visual Studio project. For each, make sure that their properties page says the <code>Item Type</code> is <code>GLSL Validator</code>. All the shader files should compile,
and the resulting SPIR-V files are stored in the <code>shaders</code> folder alongside the GLSL files. 

</p><p>

In the body of <code>createRaytracingPipeline</code>, add the definition of the new miss shader right after the previous miss shader:
</p><pre class="listing tilde"><code>  <span class="hljs-comment">// The second miss shader is invoked when a shadow ray misses the geometry. It simply indicates</span>
  <span class="hljs-comment">// that no occlusion has been found</span>
  m_shadowMissIndex =
      pipelineGen.AddMissShaderStage(VkCtx.createShaderModule(readFile(<span class="hljs-string">"shaders/shadowMiss.spv"</span>)));</code></pre><p>

The hit group for shadow rays is then added after the existing hit group:
</p><pre class="listing tilde"><code>  <span class="hljs-comment">// The second hit group defines the shaders invoked when a shadow ray hits the geometry. In this</span>
  <span class="hljs-comment">// case it only sets the ray payload to indicate some occluder has been found.</span>
  m_shadowHitGroupIndex = pipelineGen.StartHitGroup();

  pipelineGen.AddHitShaderStage(VkCtx.createShaderModule(readFile(<span class="hljs-string">"shaders/shadowClosestHit.spv"</span>)),
                                VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV);
  pipelineGen.EndHitGroup();</code></pre><p>

The pipeline should now allow shooting rays from the closest hit program, which requires increasing the recursion level to 2:
</p><pre class="listing tilde"><code>  <span class="hljs-comment">// The ray tracing process can shoot rays from the camera, and a shadow ray can be shot from the</span>
  <span class="hljs-comment">// hit points of the camera rays, hence a recursion level of 2. This number should be kept as low</span>
  <span class="hljs-comment">// as possible for performance reasons. Even recursive ray tracing should be flattened into a loop</span>
  <span class="hljs-comment">// in the ray generation to avoid deep recursion.</span>
  pipelineGen.SetMaxRecursionDepth(<span class="hljs-number">2</span>);</code></pre>
<a class="target" name="createshaderbindingtable">&nbsp;</a><h2>createShaderBindingTable</h2>
<p>


The Shader Binding Table must also be updated, by adding the new miss program after the existing one:
</p><pre class="listing tilde"><code><span class="hljs-comment">// Add the miss shader for the shadow rays</span>
m_sbtGen.AddMissProgram(m_shadowMissIndex, {});</code></pre><p>

Similarly, we add the new hit group after the one used by primary rays:
</p><pre class="listing tilde"><code><span class="hljs-comment">// Add the hit group defining the behavior upon hitting a surface with a shadow ray</span>
m_sbtGen.AddHitGroup(m_shadowHitGroupIndex, {});</code></pre>
<a class="target" name="createtoplevelas">&nbsp;</a><h2>createTopLevelAS</h2>
<p>


When creating the instances for the top-level acceleration structure, we passed the index of the instance <code>i</code>
 as the index of the
corresponding hit group. However, with two ray types, each instance has 
two hit groups: one representing the behavior when a camera
ray hits the geometry, and one used when a shadow ray hits that same 
geometry. Therefore, in the <code>AddInstance</code> call, for the instance <code>i</code> we will now use the hit group
index <code>2*i</code>:
</p><pre class="listing tilde"><code><span class="hljs-comment">// For each instance we set its instance index to its index i in the instance vector, and set</span>
<span class="hljs-comment">// its hit group index to 2*i. The hit group index defines which entry of the shader binding</span>
<span class="hljs-comment">// table will contain the hit group to be executed when hitting this instance. We set this</span>
<span class="hljs-comment">// index to 2*i due to the use of 2 types of rays in the scene: the camera rays and the shadow</span>
<span class="hljs-comment">// rays. For each instance, the SBT will then have 2 hit groups</span>
m_topLevelASGenerator.AddInstance(instances[i].first, instances[i].second,
                                  <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(i), <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(<span class="hljs-number">2</span> * i));</code></pre>
<a class="target" name="createraytracingdescriptorset">&nbsp;</a><h2>createRaytracingDescriptorSet</h2>
<p>


For each resource entry in the descriptor set we indicated which shader 
stage would be able to use it. Since shadow rays will be traced from the
 closest hit 
shader, we replace the acceleration structure binding by:
</p><pre class="listing tilde"><code><span class="hljs-comment">// Top-level acceleration structure, usable by both the ray generation and the closest hit (to</span>
<span class="hljs-comment">// shoot shadow rays)</span>
dsg.AddBinding(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV,
               VK_SHADER_STAGE_RAYGEN_BIT_NV | VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV);</code></pre>
<a class="target" name="closesthit.rchit">&nbsp;</a><h2>closesthit.rchit</h2>
<p>


The closest hit shader now needs to be aware of the acceleration structure to be able to shoot rays: 
</p><pre class="listing tilde"><code><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> accelerationStructureNV topLevelAS;</code></pre><p>

Those rays will also carry a payload, which will need to be defined at a
 different location from the payload of the current ray. However, in 
this case, 
the payload will be a simple floating-point value indicating whether an 
occluder has been found or not:
</p><pre class="listing tilde"><code><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) rayPayloadNV <span class="hljs-type">bool</span> isShadowed;</code></pre><p>

In the <code>main</code> function, instead of simply setting out payload to <code>hitValue = c;</code>, we will initiate a new ray. Note that
the index of the miss shader is now 1, since the SBT has 2 miss shaders. We also set the offset to 1, indicating that we 
will want to use the second hit group defined for the instance the ray will hit. The payload location is defined to match 
the declaration <code>layout(location = 2)</code> above.
</p><pre class="listing tilde"><code><span class="hljs-type">float</span> tmin = <span class="hljs-number">0.001</span>;
<span class="hljs-type">float</span> tmax = <span class="hljs-number">100.0</span>;
<span class="hljs-type">vec3</span> origin = gl_WorldRayOriginNV + gl_WorldRayDirectionNV * gl_HitTNV;

traceNV(topLevelAS, gl_RayFlagsOpaqueNV, <span class="hljs-number">0xFF</span>, <span class="hljs-number">1</span> <span class="hljs-comment">/* sbtRecordOffset */</span>, <span class="hljs-number">0</span> <span class="hljs-comment">/* sbtRecordStride */</span>,
        <span class="hljs-number">1</span> <span class="hljs-comment">/* missIndex */</span>, origin, tmin, lightVector, tmax, <span class="hljs-number">2</span> <span class="hljs-comment">/*payload location*/</span>);</code></pre><p>

The final payload value can then be adjusted depending on the result of the shadow ray:
</p><pre class="listing tilde"><code><span class="hljs-keyword">if</span> (isShadowed)
  hitValue = <span class="hljs-built_in">c</span> * <span class="hljs-number">0.3</span>;
<span class="hljs-keyword">else</span>
  hitValue = <span class="hljs-built_in">c</span>; </code></pre><p>

</p><center><a href="https://developer.nvidia.com/sites/default/files/pictures/2019/vulkan_raytracing/resultRaytraceShadowMedieval.png" target="_blank"><img class="markdeep" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/resultRaytraceShadowMedieval.png"></a></center> 

<p></p><p>

The final project can be downloaded <a href="https://developer.nvidia.com/rtx/raytracing/vkrt_helpers/files/vkexamples_final.zip">here</a>.

</p>
<a class="target" name="goingfurther">&nbsp;</a><h1>Going Further</h1>
<p>


From this point on, you can continue creating your own ray types and 
shaders, and experiment with more advanced ray-tracing-based algorithms.
 
This tutorial was intended to help grasping the concepts of Vulkan ray 
tracing without going into too much API details. We encourage you to go 
through the 
documentation of the <a href="https://developer.nvidia.com/rtx/raytracing/vkrt_helpers">helpers</a> to understand how each concept maps to the corresponding API calls.
</p></span></div>

<script>
  window.markdeepOptions={ mode:"html"};
</script>
<script src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/markdeep.js"></script>
</div></div></div></div>


</section>
  </div>
                  </section>

        
      </div>
    </div>
    <div class="separator"></div>
  </div>
  
  <footer>
    <div class="footer-links">
      <div class="container">
        <div class="row">
          <div class="col-xs-12 col-sm-12 col-md-3 col-lg-3">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
              <div class="padding-md-footer">
                <div class="logo-footer"></div>
              </div>
            </div>
            <div class="col-xs-12 col-sm-12 col-md-9 col-lg-9 padding-section-footer">
                <div class="region region-footer-menu">
    <div class="block block-menu" id="block-menu-menu-footer-menu">
  <div class="block-content zone-select">
    <ul class="menu nav"><li class="first leaf"><a href="https://developer.nvidia.com/computeworks" title="">COMPUTEWORKS</a></li>
<li class="leaf"><a href="https://developer.nvidia.com/gameworks" title="">GAMEWORKS</a></li>
<li class="leaf"><a href="https://developer.nvidia.com/embedded-computing" title="">JETPACK</a></li>
<li class="leaf"><a href="https://developer.nvidia.com/designworks" title="">DESIGNWORKS</a></li>
<li class="last leaf"><a href="https://developer.nvidia.com/drive" title="">DRIVE</a></li>
</ul>  </div>
</div>
  </div>
            </div>
          </div>
          <div class="col-xs-12 col-sm-12 col-md-9 col-lg-9">
                                                </div>
        </div>
      </div>
    </div>

    <div class="footer-boilerplate">
      <div class="container">
        <div class="boilerplate">
          <div class="col-xs-12 col-sm-12 col-lg-9 padding-sm-bottom">
            Copyright © 2019 NVIDIA Corporation                          <ul class="legal_links"><li class="first leaf"><a href="http://www.nvidia.com/object/legal_info.html">Legal Information</a></li>
<li class="last leaf"><a href="http://www.nvidia.com/object/privacy_policy.html">Privacy Policy</a></li>
</ul>                      </div>
        </div>
      </div>
    </div>
  </footer>
</div>
  <script>var dzauth = {"settings":{"client_id":"4jljTejN7RMO9suL0S33gFrYgjHX0VcW","redirect_uri":"https:\/\/developer.nvidia.com\/auth0\/callback","custom_domain":"login.developer.nvidia.com","domain":"devzone.auth0.com","auto_login":true}};

function nvidia_dzauth_register_and_redirect(redirect_destination) {
  if(redirect_destination) {
    history.pushState(null, '', redirect_destination);
    showDzAuth('login');
  }
}

function nvidia_dzauth_init() {
  initDzAuth(dzauth);
  if (typeof auth0 !== 'undefined') {
    dzCheckSession(auth0);
  }
}
nvidia_dzauth_init();
</script>
<script>_satellite.pageBottom();</script>
<script src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/js_FbpwIZNwgzwEuuL4Q2HOM07BOSCY5LxL_gwSK4ohQBM.js"></script>
<script type="text/javascript">window.NREUM||(NREUM={});NREUM.info={"beacon":"bam.nr-data.net","licenseKey":"9557dbf16c","applicationID":"9052762","transactionName":"ZFADMkRTVxcEARdRWl0aIAVCW1YKSj0RXUNaRggJWFtXAzoUCl1C","queueTime":0,"applicationTime":229,"atts":"SBcARAxJRBk=","errorBeacon":"bam.nr-data.net","agent":""}</script>

<div id="cboxOverlay" style="display: none;"></div><div id="colorbox" class="" role="dialog" tabindex="-1" style="display: none;"><div id="cboxWrapper"><div><div id="cboxTopLeft" style="float: left;"></div><div id="cboxTopCenter" style="float: left;"></div><div id="cboxTopRight" style="float: left;"></div></div><div style="clear: left;"><div id="cboxMiddleLeft" style="float: left;"></div><div id="cboxContent" style="float: left;"><div id="cboxTitle" style="float: left;"></div><div id="cboxCurrent" style="float: left;"></div><button type="button" id="cboxPrevious"></button><button type="button" id="cboxNext"></button><button id="cboxSlideshow"></button><div id="cboxLoadingOverlay" style="float: left;"></div><div id="cboxLoadingGraphic" style="float: left;"></div></div><div id="cboxMiddleRight" style="float: left;"></div></div><div style="clear: left;"><div id="cboxBottomLeft" style="float: left;"></div><div id="cboxBottomCenter" style="float: left;"></div><div id="cboxBottomRight" style="float: left;"></div></div></div><div style="position: absolute; width: 9999px; visibility: hidden; display: none; max-width: none;"></div></div><div id="sidr" class="sidr left"><div class="sidr-inner">

              <ul class="menu nav navbar-nav"><li class="first leaf"><a href="http://news.developer.nvidia.com/" title="">NEWS</a></li>
<li class="leaf"><a href="https://devblogs.nvidia.com/" title="">BLOG</a></li>
<li class="last leaf"><a href="https://devtalk.nvidia.com/" title="">FORUMS</a></li>
</ul>            <ul class="nav navbar-nav navbar-margin navbar-right navbar-margin-media login-nav">
                  <li class="search" id="search-top">
            <div class="search-form" id="search-top-form">
              <form class="gss form-search content-search" action="/rtx/raytracing/vkray" method="post" id="search-block-form" accept-charset="UTF-8"><div><div>
      <h2 class="element-invisible">Search form</h2>
    <div class="input-group"><input title="Enter the terms you wish to search for." placeholder="Search..." class="form-control form-text" type="text" id="edit-search-block-form--2" name="search_block_form" size="15" maxlength="128"><span class="input-group-btn"><button type="submit" class="btn btn-default"><span class="icon glyphicon glyphicon-search" aria-hidden="true"></span>
</button></span></div><div class="form-actions form-wrapper form-group" id="edit-actions"><button class="element-invisible btn btn-primary form-submit" type="submit" id="edit-submit" name="op" value="Search">Search</button>
</div><input type="hidden" name="form_build_id" value="form-eccIESa4-4sSuVZZGouDiPo0gDGcPRZoBp0LsTZYCK8">
<input type="hidden" name="form_id" value="search_block_form">
</div>
</div></form>            </div>
          </li>
        
        
          
                        <li class="leaf join-link" id="dzauth_register_link"><a href="javascript:jQuery.sidr('close');javascript:showDzAuth('register');">Join</a></li>
<li class="leaf last" id="dzauth_login_link"><a href="javascript:jQuery.sidr('close');javascript:showDzAuth('login');">Login</a></li>          
      </ul>
  </div><div class="sidr-inner">
          <ul class="menu nav navbar-nav secondary"><li class="first leaf"><a href="https://developer.nvidia.com/rtx" title="">RTX</a></li>
<li class="leaf"><a href="https://developer.nvidia.com/gameworks" title="">GAMEWORKS</a></li>
<li class="leaf"><a href="https://developer.nvidia.com/designworks" title="">DESIGNWORKS</a></li>
<li class="leaf"><a href="https://developer.nvidia.com/vrworks" title="">VRWORKS</a></li>
<li class="leaf"><a href="https://developer.nvidia.com/computeworks" title="">COMPUTEWORKS</a></li>
<li class="leaf"><a href="https://developer.nvidia.com/embedded-computing" title="">JETPACK</a></li>
<li class="leaf"><a href="https://developer.nvidia.com/drive" title="">DRIVE</a></li>
<li class="leaf"><a href="https://developer.nvidia.com/clara" title="">CLARA</a></li>
<li class="last leaf"><a href="https://developer.nvidia.com/open-source" title="">OPEN SOURCE</a></li>
</ul>                  </div></div><iframe sandbox="allow-scripts allow-same-origin" title="Adobe ID Syncing iFrame" id="destination_publishing_iframe_nvidia_0" name="destination_publishing_iframe_nvidia_0_name" style="display: none; width: 0px; height: 0px;" src="NVIDIA%20Vulkan%20Ray%20Tracing%20Tutorial%20|%20NVIDIA%20Developer_files/dest5.html" class="aamIframeLoaded"></iframe><div style="position: absolute; width: 0px; height: 0px; overflow: hidden; padding: 0px; border: 0px none; margin: 0px;"><div id="MathJax_Font_Test" style="position: absolute; visibility: hidden; top: 0px; left: 0px; width: auto; padding: 0px; border: 0px none; margin: 0px; white-space: nowrap; text-align: left; text-indent: 0px; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; font-size: 40px; font-weight: normal; font-style: normal; font-size-adjust: none; font-family: STIXSizeOneSym, sans-serif;"></div></div></body></html>